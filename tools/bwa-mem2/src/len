profiling.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
Binary file ksw.o matches
Binary file kopen.o matches
bwa.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwa.cpp:    if((decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('0')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('1')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('2')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('3')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('4')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('5')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('6')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('7')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('8')))[0]==0)
bwa.cpp:    || (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encrypt_plaintext_integer_to_ciphertext('9')))[0]==0))
bwa.cpp:    if (s->l > 2 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(s->enc_s[s->l-2], encrypt_plaintext_integer_to_ciphertext('/')))[0]==0 && isdigit_enc(s->enc_s[s->l-1]))
bwa.cpp:        s->l -= 2, s->enc_s[s->l] = encrypt_plaintext_integer_to_ciphertext(0);
bwa.cpp:    // s->name = strdup(ks->name.s);
bwa.cpp:    // s->comment = ks->comment.l? strdup(ks->comment.s) : 0;
bwa.cpp:    // s->seq = strdup(ks->seq.s);
bwa.cpp:    // s->qual = ks->qual.l? strdup(ks->qual.s) : 0;
bwa.cpp:    // s->l_seq = strlen(s->seq);
bwa.cpp:    // cout<<"(s->enc_name).size()="<<(s->enc_name).size()<<"; (s->enc_name).capacity(): "<<(s->enc_name).capacity()<<endl;
bwa.cpp:    // s->enc_name.resize((ks->name.enc_s).size());
bwa.cpp:    // for(int i=0;i<(ks->name.enc_s).size();i++)
bwa.cpp:    //     s->enc_name[i]=(ks->name.enc_s)[i];
bwa.cpp:    // cout<<"(s->enc_comment).size()="<<(s->enc_comment).size()<<"; (s->enc_comment).capacity(): "<<(s->enc_comment).capacity()<<endl;
bwa.cpp:    // s->enc_comment.resize((ks->comment.enc_s).size());
bwa.cpp:    // for(int i=0;i<(ks->comment.enc_s).size();i++)
bwa.cpp:    //     s->enc_comment[i]=(ks->comment.enc_s)[i];
bwa.cpp:    // cout<<"(s->enc_seq).size()="<<(s->enc_seq).size()<<"; (s->enc_seq).capacity(): "<<(s->enc_seq).capacity()<<endl;
bwa.cpp:    // s->enc_seq.resize((ks->seq.enc_s).size());
bwa.cpp:    // for(int i=0;i<(ks->seq.enc_s).size();i++)
bwa.cpp:    //     s->enc_seq[i]=(ks->seq.enc_s)[i];
bwa.cpp:    // cout<<"(s->enc_qual).size()="<<(s->enc_qual).size()<<"; (s->enc_qual).capacity(): "<<(s->enc_qual).capacity()<<endl;
bwa.cpp:    // s->enc_qual.resize((ks->qual.enc_s).size());
bwa.cpp:    // for(int i=0;i<(ks->qual.enc_s).size();i++)
bwa.cpp:    //     s->enc_qual[i]=(ks->qual.enc_s)[i];            
bwa.cpp:    // printf("s->enc_name: %s\n",convert_ciphertext_vector_to_plaintext_string(ks->name.enc_s));
bwa.cpp:    strdup_enc(ks->name.enc_s,s->enc_name);
bwa.cpp:    if(ks->comment.l>0)
bwa.cpp:        // printf("s->enc_comment: %s\n",convert_ciphertext_vector_to_plaintext_string(ks->comment.enc_s));
bwa.cpp:        strdup_enc(ks->comment.enc_s,s->enc_comment);
bwa.cpp:    // printf("s->enc_seq: %s\n",convert_ciphertext_vector_to_plaintext_string(ks->seq.enc_s));
bwa.cpp:    strdup_enc(ks->seq.enc_s,s->enc_seq);
bwa.cpp:    // cout<<"ks->qual.l: "<<ks->qual.l<<endl;
bwa.cpp:    if(ks->qual.l>0) 
bwa.cpp:        // printf("s->enc_qual: %s\n",convert_ciphertext_vector_to_plaintext_string(ks->qual.enc_s));
bwa.cpp:        strdup_enc(ks->qual.enc_s,s->enc_qual);
bwa.cpp:    // s->l_seq = strlen_enc(s->enc_seq);
bwa.cpp:    s->l_seq=s->enc_seq.size()-1;                           // remove the final enc('\n')
bwa.cpp:        trim_readno(&ks->name);
bwa.cpp:            //kstream_t *kst = ksd->f;
bwa.cpp:            trim_readno(&ks2->name);
bwa.cpp:    while (kseq_read(ks) >= 0)                                              // kseq_read() returns seq->seq.l
bwa.cpp:        trim_readno(&ks->name);
bwa.cpp:            trim_readno(&ks2->name);
bwa.cpp:        // int s1=strlen(ks->name.s);
bwa.cpp:        // int s2=strlen(ks->comment.s);
bwa.cpp:        // int s3=strlen(ks->seq.s);
bwa.cpp:        // int s4=strlen(ks->qual.s);
bwa.cpp:        // int s5=strlen(ks->f->buf);
bwa.cpp:        int s6=((ks->name).enc_s).size()*sizeof((ks->name).enc_s[0]);
bwa.cpp:        int s7=((ks->comment).enc_s).size()*sizeof((ks->comment).enc_s[0]);
bwa.cpp:        int s8=((ks->seq).enc_s).size()*sizeof((ks->seq).enc_s[0]);
bwa.cpp:        int s9=((ks->qual).enc_s).size()*sizeof((ks->qual).enc_s[0]);
bwa.cpp:        int s10=(ks->f->enc_buf.size())*sizeof(ks->f->enc_buf[0]);
bwa.cpp:        int s11=(seqs[n-1].enc_name).size()*sizeof(seqs[n-1].enc_name[0]);
bwa.cpp:        int s12=(seqs[n-1].enc_comment).size()*sizeof(seqs[n-1].enc_comment[0]);
bwa.cpp:        int s13=(seqs[n-1].enc_seq).size()*sizeof(seqs[n-1].enc_seq[0]);
bwa.cpp:        int s14=(seqs[n-1].enc_qual).size()*sizeof(seqs[n-1].enc_qual[0]);
bwa.cpp:        // printf("strlen(ks->name.s): %d, strlen(ks->comment.s): %d, strlen(ks->seq.s): %d, strlen(ks->qual.s): %d, strlen(ks->f->buf): %s,((ks->name).enc_s).size(): %d, ((ks->comment).enc_s).size(): %d, ((ks->seq).enc_s).size(): %d, ((ks->qual).enc_s).size(): %d, (ks->f->enc_s).size(): %d, (seqs[n].enc_name).size(): %d, (seqs[n].enc_comment).size(): %d, (seqs[n].enc_seq).size(): %d, (seqs[n].enc_qual).size(): %d;\n",s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14);
bwa.cpp:        printf("((ks->name).enc_s).size(): %d, ((ks->comment).enc_s).size(): %d, ((ks->seq).enc_s).size(): %d, ((ks->qual).enc_s).size(): %d, (ks->f->enc_s).size(): %d, (seqs[n].enc_name).size(): %d, (seqs[n].enc_comment).size(): %d, (seqs[n].enc_seq).size(): %d, (seqs[n].enc_qual).size(): %d;\n",s6,s7,s8,s9,s10,s11,s12,s13,s14);
bwa.cpp:        printf("------------------------------\n");
bwa.cpp:    kseq_t *ks = kseq_init(fp);                                         // ks->f=fp in kseq_init
bwa.cpp:            if (strcmp(seqs[i].name, seqs[i-1].name) == 0) {
bwa.cpp:                kv_push(bseq1_t, a[1], seqs[i-1]);
bwa.cpp:            } else kv_push(bseq1_t, a[0], seqs[i-1]);
bwa.cpp:    if (has_last) kv_push(bseq1_t, a[0], seqs[i-1]);
bwa.cpp:            mat[k++] = i == j? a : -b;
bwa.cpp:        mat[k++] = -1; // ambiguous base
bwa.cpp:    for (j = 0; j < 5; ++j) mat[k++] = -1;   // DEFAULT AMBIG
bwa.cpp:    if (NM) *NM = -1;
bwa.cpp:    if (re - rb != rlen) goto ret_gen_cigar; // possible if out of range
bwa.cpp:            tmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;
bwa.cpp:            tmp = rseq[i], rseq[i] = rseq[rlen - 1 - i], rseq[rlen - 1 - i] = tmp;
bwa.cpp:    if (l_query == re - rb && w_ == 0) { // no gap; no need to do DP
bwa.cpp:        // set the band-width
bwa.cpp:        max_ins = (int)((double)(((l_query+1)>>1) * mat[0] - o_ins) / e_ins + 1.);
bwa.cpp:        max_del = (int)((double)(((l_query+1)>>1) * mat[0] - o_del) / e_del + 1.);
bwa.cpp:        w = (max_gap + abs(rlen - l_query) + 1) >> 1;
bwa.cpp:        min_w = abs(rlen - l_query) + 3;
bwa.cpp:                if (k > 0 && k < *n_cigar - 1) { // don't do the following if D is the first or the last CIGAR
bwa.cpp:            tmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;
bwa.cpp:    strcat(strcpy(tmp, prefix), ".bwt"); // FM-index
bwa.cpp:    if (which & BWA_IDX_BWT) idx->bwt = bwa_idx_load_bwt(hint);
bwa.cpp:        idx->bns = bns_restore(prefix);
bwa.cpp:        assert(idx->bns != 0);
bwa.cpp:        for (i = c = 0; i < idx->bns->n_seqs; ++i)
bwa.cpp:            if (idx->bns->anns[i].is_alt) ++c;
bwa.cpp:            idx->pac = (uint8_t*) calloc(idx->bns->l_pac/4+1, 1);
bwa.cpp:            err_fread_noeof(idx->pac, 1, idx->bns->l_pac/4+1, idx->bns->fp_pac); // concatenated 2-bit encoded sequence
bwa.cpp:            err_fclose(idx->bns->fp_pac);
bwa.cpp:            idx->bns->fp_pac = 0;
bwa.cpp:    if (idx->mem == 0) {
bwa.cpp:        if (idx->bwt) bwt_destroy(idx->bwt);
bwa.cpp:        if (idx->bns) bns_destroy(idx->bns);
bwa.cpp:        if (idx->pac) free(idx->pac);
bwa.cpp:        free(idx->bwt); free(idx->bns->anns); free(idx->bns);
bwa.cpp:        if (!idx->is_shm) free(idx->mem);
bwa.cpp:    // generate idx->bwt
bwa.cpp:    x = sizeof(bwt_t); idx->bwt = (bwt_t*) malloc(x); memcpy(idx->bwt, mem + k, x); k += x;
bwa.cpp:    x = idx->bwt->bwt_size * 4; idx->bwt->bwt = (uint32_t*)(mem + k); k += x;
bwa.cpp:    x = idx->bwt->n_sa * sizeof(bwtint_t); idx->bwt->sa = (bwtint_t*)(mem + k); k += x;
bwa.cpp:    // generate idx->bns and idx->pac
bwa.cpp:    x = sizeof(bntseq_t); idx->bns = (bntseq_t*) malloc(x); memcpy(idx->bns, mem + k, x); k += x;
bwa.cpp:    x = idx->bns->n_holes * sizeof(bntamb1_t); idx->bns->ambs = (bntamb1_t*)(mem + k); k += x;
bwa.cpp:    x = idx->bns->n_seqs  * sizeof(bntann1_t); idx->bns->anns = (bntann1_t*) malloc(x); memcpy(idx->bns->anns, mem + k, x); k += x;
bwa.cpp:    for (i = 0; i < idx->bns->n_seqs; ++i) {
bwa.cpp:        idx->bns->anns[i].name = (char*)(mem + k); k += strlen(idx->bns->anns[i].name) + 1;
bwa.cpp:        idx->bns->anns[i].anno = (char*)(mem + k); k += strlen(idx->bns->anns[i].anno) + 1;
bwa.cpp:    idx->pac = (uint8_t*)(mem + k); k += idx->bns->l_pac/4+1;
bwa.cpp:    idx->l_mem = k; idx->mem = mem;
bwa.cpp:    // copy idx->bwt
bwa.cpp:    x = idx->bwt->bwt_size * 4;
bwa.cpp:    mem = (uint8_t*) realloc(idx->bwt->bwt, sizeof(bwt_t) + x); idx->bwt->bwt = 0;
bwa.cpp:    memcpy(mem, idx->bwt, sizeof(bwt_t)); k = sizeof(bwt_t) + x;
bwa.cpp:    x = idx->bwt->n_sa * sizeof(bwtint_t); mem = (uint8_t*) realloc(mem, k + x); memcpy(mem + k, idx->bwt->sa, x); k += x;
bwa.cpp:    free(idx->bwt->sa);
bwa.cpp:    free(idx->bwt); idx->bwt = 0;
bwa.cpp:    // copy idx->bns
bwa.cpp:    tmp = idx->bns->n_seqs * sizeof(bntann1_t) + idx->bns->n_holes * sizeof(bntamb1_t);
bwa.cpp:    for (i = 0; i < idx->bns->n_seqs; ++i) // compute the size of heap-allocated memory
bwa.cpp:        tmp += strlen(idx->bns->anns[i].name) + strlen(idx->bns->anns[i].anno) + 2;
bwa.cpp:    x = sizeof(bntseq_t); memcpy(mem + k, idx->bns, x); k += x;
bwa.cpp:    x = idx->bns->n_holes * sizeof(bntamb1_t); memcpy(mem + k, idx->bns->ambs, x); k += x;
bwa.cpp:    free(idx->bns->ambs);
bwa.cpp:    x = idx->bns->n_seqs * sizeof(bntann1_t); memcpy(mem + k, idx->bns->anns, x); k += x;
bwa.cpp:    for (i = 0; i < idx->bns->n_seqs; ++i) {
bwa.cpp:        x = strlen(idx->bns->anns[i].name) + 1; memcpy(mem + k, idx->bns->anns[i].name, x); k += x;
bwa.cpp:        x = strlen(idx->bns->anns[i].anno) + 1; memcpy(mem + k, idx->bns->anns[i].anno, x); k += x;
bwa.cpp:        free(idx->bns->anns[i].name); free(idx->bns->anns[i].anno);
bwa.cpp:    free(idx->bns->anns);
bwa.cpp:    // copy idx->pac
bwa.cpp:    x = idx->bns->l_pac/4+1;
bwa.cpp:    memcpy(mem + k, idx->pac, x); k += x;
bwa.cpp:    free(idx->bns); idx->bns = 0;
bwa.cpp:    free(idx->pac); idx->pac = 0;
bwa.cpp:            if (p == hdr_line || *(p-1) == '\n') ++n_SQ;
bwa.cpp:        for (i = 0; i < bns->n_seqs; ++i) {
bwa.cpp:            err_printf("@SQ\tSN:%s\tLN:%d", bns->anns[i].name, bns->anns[i].len);
bwa.cpp:            if (bns->anns[i].is_alt) err_printf("\tAH:*\n");
bwa.cpp:            sprintf(buf, "@SQ\tSN:%s\tLN:%d", bns->anns[i].name, bns->anns[i].len);
bwa.cpp:            if (bns->anns[i].is_alt) {
bwa.cpp:    } else if (n_SQ != bns->n_seqs && bwa_verbose >= 2)
bwa.cpp:        fprintf(stderr, "[W::%s] %d @SQ lines provided with -H; %d sequences in the index. "
bwa.cpp:               "Continue anyway.\n", __func__, n_SQ, bns->n_seqs);
bwa.cpp:    if (q - p + 1 > 256) {
bwa.cpp://    BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwa.cpp://     if (s->l > 2 && s->s[s->l-2] == '/' && isdigit(s->s[s->l-1]))
bwa.cpp://         s->l -= 2, s->s[s->l] = 0;
bwa.cpp://     s->name = strdup(convert_ciphertext_vector_to_plaintext_string(ks->name.enc_s));
bwa.cpp://     s->comment = ks->comment.l? strdup(convert_ciphertext_vector_to_plaintext_string(ks->comment.enc_s)) : 0;
bwa.cpp://     s->seq = strdup(convert_ciphertext_vector_to_plaintext_string(ks->seq.enc_s));
bwa.cpp://     s->qual = ks->qual.l? strdup(convert_ciphertext_vector_to_plaintext_string(ks->qual.enc_s)) : 0;
bwa.cpp://     s->l_seq = strlen(s->seq);
bwa.cpp://         trim_readno(&ks->name);
bwa.cpp://             //kstream_t *kst = ksd->f;
bwa.cpp://             trim_readno(&ks2->name);
bwa.cpp://         trim_readno(&ks->name);
bwa.cpp://             trim_readno(&ks2->name);
bwa.cpp://             if (strcmp(seqs[i].name, seqs[i-1].name) == 0) {
bwa.cpp://                 kv_push(bseq1_t, a[1], seqs[i-1]);
bwa.cpp://             } else kv_push(bseq1_t, a[0], seqs[i-1]);
bwa.cpp://     if (has_last) kv_push(bseq1_t, a[0], seqs[i-1]);
bwa.cpp://             mat[k++] = i == j? a : -b;
bwa.cpp://         mat[k++] = -1; // ambiguous base
bwa.cpp://     for (j = 0; j < 5; ++j) mat[k++] = -1;   // DEFAULT AMBIG
bwa.cpp://     if (NM) *NM = -1;
bwa.cpp://     if (re - rb != rlen) goto ret_gen_cigar; // possible if out of range
bwa.cpp://             tmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;
bwa.cpp://             tmp = rseq[i], rseq[i] = rseq[rlen - 1 - i], rseq[rlen - 1 - i] = tmp;
bwa.cpp://     if (l_query == re - rb && w_ == 0) { // no gap; no need to do DP
bwa.cpp://         // set the band-width
bwa.cpp://         max_ins = (int)((double)(((l_query+1)>>1) * mat[0] - o_ins) / e_ins + 1.);
bwa.cpp://         max_del = (int)((double)(((l_query+1)>>1) * mat[0] - o_del) / e_del + 1.);
bwa.cpp://         w = (max_gap + abs(rlen - l_query) + 1) >> 1;
bwa.cpp://         min_w = abs(rlen - l_query) + 3;
bwa.cpp://                 if (k > 0 && k < *n_cigar - 1) { // don't do the following if D is the first or the last CIGAR
bwa.cpp://             tmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;
bwa.cpp://     strcat(strcpy(tmp, prefix), ".bwt"); // FM-index
bwa.cpp://     if (which & BWA_IDX_BWT) idx->bwt = bwa_idx_load_bwt(hint);
bwa.cpp://         idx->bns = bns_restore(prefix);
bwa.cpp://         assert(idx->bns != 0);
bwa.cpp://         for (i = c = 0; i < idx->bns->n_seqs; ++i)
bwa.cpp://             if (idx->bns->anns[i].is_alt) ++c;
bwa.cpp://             idx->pac = (uint8_t*) calloc(idx->bns->l_pac/4+1, 1);
bwa.cpp://             err_fread_noeof(idx->pac, 1, idx->bns->l_pac/4+1, idx->bns->fp_pac); // concatenated 2-bit encoded sequence
bwa.cpp://             err_fclose(idx->bns->fp_pac);
bwa.cpp://             idx->bns->fp_pac = 0;
bwa.cpp://     if (idx->mem == 0) {
bwa.cpp://         if (idx->bwt) bwt_destroy(idx->bwt);
bwa.cpp://         if (idx->bns) bns_destroy(idx->bns);
bwa.cpp://         if (idx->pac) free(idx->pac);
bwa.cpp://         free(idx->bwt); free(idx->bns->anns); free(idx->bns);
bwa.cpp://         if (!idx->is_shm) free(idx->mem);
bwa.cpp://     // generate idx->bwt
bwa.cpp://     x = sizeof(bwt_t); idx->bwt = (bwt_t*) malloc(x); memcpy(idx->bwt, mem + k, x); k += x;
bwa.cpp://     x = idx->bwt->bwt_size * 4; idx->bwt->bwt = (uint32_t*)(mem + k); k += x;
bwa.cpp://     x = idx->bwt->n_sa * sizeof(bwtint_t); idx->bwt->sa = (bwtint_t*)(mem + k); k += x;
bwa.cpp://     // generate idx->bns and idx->pac
bwa.cpp://     x = sizeof(bntseq_t); idx->bns = (bntseq_t*) malloc(x); memcpy(idx->bns, mem + k, x); k += x;
bwa.cpp://     x = idx->bns->n_holes * sizeof(bntamb1_t); idx->bns->ambs = (bntamb1_t*)(mem + k); k += x;
bwa.cpp://     x = idx->bns->n_seqs  * sizeof(bntann1_t); idx->bns->anns = (bntann1_t*) malloc(x); memcpy(idx->bns->anns, mem + k, x); k += x;
bwa.cpp://     for (i = 0; i < idx->bns->n_seqs; ++i) {
bwa.cpp://         idx->bns->anns[i].name = (char*)(mem + k); k += strlen(idx->bns->anns[i].name) + 1;
bwa.cpp://         idx->bns->anns[i].anno = (char*)(mem + k); k += strlen(idx->bns->anns[i].anno) + 1;
bwa.cpp://     idx->pac = (uint8_t*)(mem + k); k += idx->bns->l_pac/4+1;
bwa.cpp://     idx->l_mem = k; idx->mem = mem;
bwa.cpp://     // copy idx->bwt
bwa.cpp://     x = idx->bwt->bwt_size * 4;
bwa.cpp://     mem = (uint8_t*) realloc(idx->bwt->bwt, sizeof(bwt_t) + x); idx->bwt->bwt = 0;
bwa.cpp://     memcpy(mem, idx->bwt, sizeof(bwt_t)); k = sizeof(bwt_t) + x;
bwa.cpp://     x = idx->bwt->n_sa * sizeof(bwtint_t); mem = (uint8_t*) realloc(mem, k + x); memcpy(mem + k, idx->bwt->sa, x); k += x;
bwa.cpp://     free(idx->bwt->sa);
bwa.cpp://     free(idx->bwt); idx->bwt = 0;
bwa.cpp://     // copy idx->bns
bwa.cpp://     tmp = idx->bns->n_seqs * sizeof(bntann1_t) + idx->bns->n_holes * sizeof(bntamb1_t);
bwa.cpp://     for (i = 0; i < idx->bns->n_seqs; ++i) // compute the size of heap-allocated memory
bwa.cpp://         tmp += strlen(idx->bns->anns[i].name) + strlen(idx->bns->anns[i].anno) + 2;
bwa.cpp://     x = sizeof(bntseq_t); memcpy(mem + k, idx->bns, x); k += x;
bwa.cpp://     x = idx->bns->n_holes * sizeof(bntamb1_t); memcpy(mem + k, idx->bns->ambs, x); k += x;
bwa.cpp://     free(idx->bns->ambs);
bwa.cpp://     x = idx->bns->n_seqs * sizeof(bntann1_t); memcpy(mem + k, idx->bns->anns, x); k += x;
bwa.cpp://     for (i = 0; i < idx->bns->n_seqs; ++i) {
bwa.cpp://         x = strlen(idx->bns->anns[i].name) + 1; memcpy(mem + k, idx->bns->anns[i].name, x); k += x;
bwa.cpp://         x = strlen(idx->bns->anns[i].anno) + 1; memcpy(mem + k, idx->bns->anns[i].anno, x); k += x;
bwa.cpp://         free(idx->bns->anns[i].name); free(idx->bns->anns[i].anno);
bwa.cpp://     free(idx->bns->anns);
bwa.cpp://     // copy idx->pac
bwa.cpp://     x = idx->bns->l_pac/4+1;
bwa.cpp://     memcpy(mem + k, idx->pac, x); k += x;
bwa.cpp://     free(idx->bns); idx->bns = 0;
bwa.cpp://     free(idx->pac); idx->pac = 0;
bwa.cpp://             if (p == hdr_line || *(p-1) == '\n') ++n_SQ;
bwa.cpp://         for (i = 0; i < bns->n_seqs; ++i) {
bwa.cpp://             err_printf("@SQ\tSN:%s\tLN:%d", bns->anns[i].name, bns->anns[i].len);
bwa.cpp://             if (bns->anns[i].is_alt) err_printf("\tAH:*\n");
bwa.cpp://             sprintf(buf, "@SQ\tSN:%s\tLN:%d", bns->anns[i].name, bns->anns[i].len);
bwa.cpp://             if (bns->anns[i].is_alt) {
bwa.cpp://     } else if (n_SQ != bns->n_seqs && bwa_verbose >= 2)
bwa.cpp://         fprintf(stderr, "[W::%s] %d @SQ lines provided with -H; %d sequences in the index. "
bwa.cpp://                "Continue anyway.\n", __func__, n_SQ, bns->n_seqs);
bwa.cpp://     if (q - p + 1 > 256) {
bandedSWA.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bandedSWA.cpp:// ------------------------------------------------------------------------------------
bandedSWA.cpp://-----------------------------------------------------------------------------------
bandedSWA.cpp:    this->m = 5;
bandedSWA.cpp:    this->end_bonus = end_bonus;
bandedSWA.cpp:    this->zdrop = zdrop;
bandedSWA.cpp:    this->o_del = o_del;
bandedSWA.cpp:    this->o_ins = o_ins;
bandedSWA.cpp:    this->e_del = e_del;
bandedSWA.cpp:    this->e_ins = e_ins;
bandedSWA.cpp:    this->w_match    = w_match;
bandedSWA.cpp:    this->w_mismatch = w_mismatch*-1;
bandedSWA.cpp:    this->w_open     = o_del;  // redundant, used in vector code.
bandedSWA.cpp:    this->w_extend   = e_del;  // redundant, used in vector code.
bandedSWA.cpp:    this->w_ambig    = DEFAULT_AMBIG;
bandedSWA.cpp:    this->swTicks = 0;
bandedSWA.cpp:    this->SW_cells = 0;
bandedSWA.cpp:    this->F8_ = this->H8_  = this->H8__ = NULL;
bandedSWA.cpp:    this->F16_ = this->H16_  = this->H16__ = NULL;
bandedSWA.cpp:// ------------------------------------------------------------------------------------
bandedSWA.cpp:// Banded SWA - scalar code
bandedSWA.cpp:// ------------------------------------------------------------------------------------
bandedSWA.cpp:        //for (j = 0; j < qlen; ++j) qp[i++] = p[query[j]-48];  //sub 48
bandedSWA.cpp:    eh[0].h = h0; eh[1].h = h0 > oe_ins? h0 - oe_ins : 0;
bandedSWA.cpp:    for (j = 2; j <= qlen && eh[j-1].h > e_ins; ++j)
bandedSWA.cpp:        eh[j].h = eh[j-1].h - e_ins;
bandedSWA.cpp:    max_ins = (int)((double)(qlen * max + end_bonus - o_ins) / e_ins + 1.);
bandedSWA.cpp:    max_del = (int)((double)(qlen * max + end_bonus - o_del) / e_del + 1.);
bandedSWA.cpp:    max = h0, max_i = max_j = -1; max_ie = -1, gscore = -1;
bandedSWA.cpp:        int t, f = 0, h1, m = 0, mj = -1;
bandedSWA.cpp:        //int8_t *q = &qp[(target[i]-48) * qlen];   // sub 48
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:            h1 = h0 - (o_del + e_del * (i + 1));
bandedSWA.cpp:            // At the beginning of the loop: eh[j] = { H(i-1,j-1), E(i,j) }, f = F(i,j) and h1 = H(i,j-1)
bandedSWA.cpp:            // Similar to SSE2-SW, cells are computed in the following order:
bandedSWA.cpp:            //   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
bandedSWA.cpp:            //   E(i+1,j) = max{H(i,j)-gapo, E(i,j)} - gape
bandedSWA.cpp:            //   F(i,j+1) = max{H(i,j)-gapo, F(i,j)} - gape
bandedSWA.cpp:            int h, M = p->h, e = p->e; // get H(i-1,j-1) and E(i-1,j)
bandedSWA.cpp:            p->h = h1;          // set H(i,j-1) for the next row
bandedSWA.cpp:            h = M > e? M : e;   // e and f are guaranteed to be non-negative, so h>=0 even if M<0
bandedSWA.cpp:            t = M - oe_del;
bandedSWA.cpp:            e -= e_del;
bandedSWA.cpp:            p->e = e;           // save E(i+1,j) for the next row
bandedSWA.cpp:            t = M - oe_ins;
bandedSWA.cpp:            f -= e_ins;
bandedSWA.cpp:            max_off = max_off > abs(mj - i)? max_off : abs(mj - i);
bandedSWA.cpp:            if (i - max_i > mj - max_j) {
bandedSWA.cpp:                if (max - m - ((i - max_i) - (mj - max_j)) * e_del > zdrop) break;
bandedSWA.cpp:                if (max - m - ((mj - max_j) - (i - max_i)) * e_ins > zdrop) break;
bandedSWA.cpp:        for (j = end; (j >= beg) && eh[j].h == 0 && eh[j].e == 0; --j);
bandedSWA.cpp:// -------------------------------------------------------------
bandedSWA.cpp://-------------------------------------------------------------
bandedSWA.cpp:        uint8_t *seq1 = seqBufRef + p->idr;
bandedSWA.cpp:        uint8_t *seq2 = seqBufQer + p->idq;
bandedSWA.cpp:        p->score = scalarBandedSWA(p->len2, seq2, p->len1,
bandedSWA.cpp:                                   seq1, w, p->h0, &p->qle, &p->tle,
bandedSWA.cpp:                                   &p->gtle, &p->gscore, &p->max_off);      
bandedSWA.cpp://------------------------------------------------------------------------------
bandedSWA.cpp:// ------------------------ vec-8 ---------------------------------------------
bandedSWA.cpp:// ------------------------ vec 16 --------------------------------------------------
bandedSWA.cpp:// ------------------------------------------------------------------------------------
bandedSWA.cpp://----------------------------------------------------------------------------------
bandedSWA.cpp:// B-SWA - Vector code
bandedSWA.cpp:// ------------------------- AVX2 - 8 bit SIMD_LANES ---------------------------
bandedSWA.cpp:        int32_t pos = sp.id - first;
bandedSWA.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH8 - 1)/SIMD_WIDTH8 ) * SIMD_WIDTH8;
bandedSWA.cpp:#if SORT_PAIRS     // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsLen(pairArray + first, last - first, myTempArray, myHist);
bandedSWA.cpp:        __m256i eb_ins256 = _mm256_set1_epi8(eb - o_ins);
bandedSWA.cpp:        __m256i eb_del256 = _mm256_set1_epi8(eb - o_del);
bandedSWA.cpp://--------------------
bandedSWA.cpp://-------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp:                // __m256i h1_256 = _mm256_load_si256((__m256i *) (H1 + (k-1) * SIMD_WIDTH8));
bandedSWA.cpp://------------------------
bandedSWA.cpp:            /* Banding calculation in pre-processing */
bandedSWA.cpp:#if SORT_PAIRS      // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsId(pairArray + first, first, last - first, myTempArray);
bandedSWA.cpp:    setupTicks = st2 - st1;
bandedSWA.cpp:    sort1Ticks = st3 - st2;
bandedSWA.cpp:    swTicks = st4 - st3;
bandedSWA.cpp:    sort2Ticks = st5 - st4;
bandedSWA.cpp:    __m256i match256     = _mm256_set1_epi8(this->w_match);
bandedSWA.cpp:    __m256i mismatch256  = _mm256_set1_epi8(this->w_mismatch);
bandedSWA.cpp:    __m256i gapOpen256   = _mm256_set1_epi8(this->w_open);
bandedSWA.cpp:    __m256i gapExtend256 = _mm256_set1_epi8(this->w_extend);
bandedSWA.cpp:    __m256i gapOE256     = _mm256_set1_epi8(this->w_open + this->w_extend);
bandedSWA.cpp:    __m256i w_ambig_256  = _mm256_set1_epi8(this->w_ambig); // ambig penalty
bandedSWA.cpp:    __m256i e_del256    = _mm256_set1_epi8(this->e_del);
bandedSWA.cpp:    __m256i oe_del256   = _mm256_set1_epi8(this->o_del + this->e_del);
bandedSWA.cpp:    __m256i e_ins256    = _mm256_set1_epi8(this->e_ins);
bandedSWA.cpp:    __m256i oe_ins256   = _mm256_set1_epi8(this->o_ins + this->e_ins);
bandedSWA.cpp:    minq -= 1; // for gscore
bandedSWA.cpp:    __m256i gscore = _mm256_set1_epi8(-1);
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:        prof[DP3][0] += __rdtsc() - tim1;
bandedSWA.cpp:        // Z-score
bandedSWA.cpp:        prof[DP1][0] += __rdtsc() - tim1;
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        prof[DP2][0] += __rdtsc() - tim1;
bandedSWA.cpp:    prof[DP][0] += __rdtsc() - tim;
bandedSWA.cpp:// ------------------------- AVX2 - 16 bit SIMD_LANES ---------------------------
bandedSWA.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH16 - 1)/SIMD_WIDTH16 ) * SIMD_WIDTH16;
bandedSWA.cpp:#if SORT_PAIRS      // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsLen(pairArray + first, last - first, myTempArray, myHist, myHistb);
bandedSWA.cpp:        __m256i eb_ins256 = _mm256_set1_epi16(eb - o_ins);
bandedSWA.cpp:        __m256i eb_del256 = _mm256_set1_epi16(eb - o_del);
bandedSWA.cpp://--------------------
bandedSWA.cpp://-------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp:#if SORT_PAIRS      // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsId(pairArray + first, first, last - first, myTempArray);
bandedSWA.cpp:    setupTicks += st2 - st1;
bandedSWA.cpp:    sort1Ticks += st3 - st2;
bandedSWA.cpp:    swTicks += st4 - st3;
bandedSWA.cpp:    sort2Ticks += st5 - st4;
bandedSWA.cpp:    __m256i match256     = _mm256_set1_epi16(this->w_match);
bandedSWA.cpp:    __m256i mismatch256  = _mm256_set1_epi16(this->w_mismatch);
bandedSWA.cpp:    __m256i gapOpen256   = _mm256_set1_epi16(this->w_open);
bandedSWA.cpp:    __m256i gapExtend256 = _mm256_set1_epi16(this->w_extend);
bandedSWA.cpp:    __m256i gapOE256     = _mm256_set1_epi16(this->w_open + this->w_extend);
bandedSWA.cpp:    __m256i w_ambig_256  = _mm256_set1_epi16(this->w_ambig);    // ambig penalty
bandedSWA.cpp:    __m256i e_del256    = _mm256_set1_epi16(this->e_del);
bandedSWA.cpp:    __m256i oe_del256   = _mm256_set1_epi16(this->o_del + this->e_del);
bandedSWA.cpp:    __m256i e_ins256    = _mm256_set1_epi16(this->e_ins);
bandedSWA.cpp:    __m256i oe_ins256   = _mm256_set1_epi16(this->o_ins + this->e_ins);
bandedSWA.cpp:    minq -= 1; // for gscore
bandedSWA.cpp:    __m256i gscore = _mm256_set1_epi16(-1);
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:        prof[DP3][0] += __rdtsc() - tim1;
bandedSWA.cpp:        // Z-score
bandedSWA.cpp:        prof[DP1][0] += __rdtsc() - tim1;
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        prof[DP2][0] += __rdtsc() - tim1;
bandedSWA.cpp:    prof[DP][0] += __rdtsc() - tim;
bandedSWA.cpp:// ----------------------------------------------------------------------------------
bandedSWA.cpp:// AVX512- vec8, vec16 SIMD code
bandedSWA.cpp:// ----------------------------------------------------------------------------------
bandedSWA.cpp:// ------------------------ vec 8 --------------------------------------------------
bandedSWA.cpp:// ------------------------ vec 16 --------------------------------------------------
bandedSWA.cpp:        int32_t pos = sp.id - first;
bandedSWA.cpp:// ____________________________ AVX512 - getScore() _______________________________________
bandedSWA.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH8 - 1)/SIMD_WIDTH8 ) * SIMD_WIDTH8;
bandedSWA.cpp:        pairArray[ii].len2 = pairArray[numPairs - 1].len2;
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsLen(pairArray + first, last - first, myTempArray, myHist, myHistb);
bandedSWA.cpp:        __m512i eb_ins512 = _mm512_set1_epi8(eb - o_ins);
bandedSWA.cpp:        __m512i eb_del512 = _mm512_set1_epi8(eb - o_del);
bandedSWA.cpp://--------------------
bandedSWA.cpp://-------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp:            /* Banding calculation in pre-processing */
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsId(pairArray + first, first, last - first, myTempArray);
bandedSWA.cpp:    setupTicks = st2 - st1;
bandedSWA.cpp:    sort1Ticks = st3 - st2;
bandedSWA.cpp:    swTicks = st4 - st3;
bandedSWA.cpp:    sort2Ticks = st5 - st4;
bandedSWA.cpp:    __m512i match512     = _mm512_set1_epi8(this->w_match);
bandedSWA.cpp:    __m512i mismatch512  = _mm512_set1_epi8(this->w_mismatch);
bandedSWA.cpp:    __m512i gapOpen512   = _mm512_set1_epi8(this->w_open);
bandedSWA.cpp:    __m512i gapExtend512 = _mm512_set1_epi8(this->w_extend);
bandedSWA.cpp:    __m512i gapOE512     = _mm512_set1_epi8(this->w_open + this->w_extend);
bandedSWA.cpp:    __m512i w_ambig_512  = _mm512_set1_epi8(this->w_ambig); // ambig penalty
bandedSWA.cpp:    __m512i e_del512    = _mm512_set1_epi8(this->e_del);
bandedSWA.cpp:    __m512i oe_del512   = _mm512_set1_epi8(this->o_del + this->e_del);
bandedSWA.cpp:    __m512i e_ins512    = _mm512_set1_epi8(this->e_ins);
bandedSWA.cpp:    __m512i oe_ins512   = _mm512_set1_epi8(this->o_ins + this->e_ins);  
bandedSWA.cpp:    minq -= 1; // for gscore
bandedSWA.cpp:    __m512i gscore     = _mm512_set1_epi8(-1);
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:        prof[DP3][0] += __rdtsc() - tim1;
bandedSWA.cpp:        /* Z-score condition for exit */
bandedSWA.cpp:        prof[DP1][0] += __rdtsc() - tim1;
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        prof[DP2][0] += __rdtsc() - tim1;
bandedSWA.cpp:    prof[DP][0] += __rdtsc() - tim;
bandedSWA.cpp://----------------------------AVX512 vec 16 bit SIMD lane -------------------------------------
bandedSWA.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH16 - 1)/SIMD_WIDTH16 ) * SIMD_WIDTH16;
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsLen(pairArray + first, last - first, myTempArray, myHist);
bandedSWA.cpp:        __m512i eb_ins512 = _mm512_set1_epi16(eb - o_ins);
bandedSWA.cpp:        __m512i eb_del512 = _mm512_set1_epi16(eb - o_del);
bandedSWA.cpp://--------------------
bandedSWA.cpp://-------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp:            /* Banding calculation in pre-processing */
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsId(pairArray + first, first, last - first, myTempArray);
bandedSWA.cpp:    setupTicks += st2 - st1;
bandedSWA.cpp:    sort1Ticks += st3 - st2;
bandedSWA.cpp:    swTicks += st4 - st3;
bandedSWA.cpp:    sort2Ticks += st5 - st4;
bandedSWA.cpp:    __m512i match512     = _mm512_set1_epi16(this->w_match);
bandedSWA.cpp:    __m512i mismatch512  = _mm512_set1_epi16(this->w_mismatch);
bandedSWA.cpp:    __m512i gapOpen512   = _mm512_set1_epi16(this->w_open);
bandedSWA.cpp:    __m512i gapExtend512 = _mm512_set1_epi16(this->w_extend);
bandedSWA.cpp:    __m512i gapOE512     = _mm512_set1_epi16(this->w_open + this->w_extend);
bandedSWA.cpp:    __m512i w_ambig_512  = _mm512_set1_epi16(this->w_ambig);    // ambig penalty
bandedSWA.cpp:    __m512i e_del512    = _mm512_set1_epi16(this->e_del);
bandedSWA.cpp:    __m512i oe_del512   = _mm512_set1_epi16(this->o_del + this->e_del);
bandedSWA.cpp:    __m512i e_ins512    = _mm512_set1_epi16(this->e_ins);
bandedSWA.cpp:    __m512i oe_ins512   = _mm512_set1_epi16(this->o_ins + this->e_ins);
bandedSWA.cpp:    minq -= 1; // for gscore
bandedSWA.cpp:    __m512i gscore     = _mm512_set1_epi16(-1);
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:        prof[DP3][0] += __rdtsc() - tim1;
bandedSWA.cpp:        /* Z-score condition for exit */
bandedSWA.cpp:        prof[DP1][0] += __rdtsc() - tim1;
bandedSWA.cpp:        for (l = end; l >= beg; l--) {
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        prof[DP2][0] += __rdtsc() - tim1;
bandedSWA.cpp:    prof[DP][0] += __rdtsc() - tim;
bandedSWA.cpp:// SSE2 =- 16 bit version
bandedSWA.cpp:        int32_t pos = sp.id - first;
bandedSWA.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH16 - 1)/SIMD_WIDTH16 ) * SIMD_WIDTH16;
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsLen(pairArray + first, last - first, myTempArray, myHist, myHistb);
bandedSWA.cpp:        __m128i eb_ins128 = _mm_set1_epi16(eb - o_ins);
bandedSWA.cpp:        __m128i eb_del128 = _mm_set1_epi16(eb - o_del);
bandedSWA.cpp://--------------------
bandedSWA.cpp://-------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsId(pairArray + first, first, last - first, myTempArray);
bandedSWA.cpp:    setupTicks += st2 - st1;
bandedSWA.cpp:    sort1Ticks += st3 - st2;
bandedSWA.cpp:    swTicks += st4 - st3;
bandedSWA.cpp:    sort2Ticks += st5 - st4;
bandedSWA.cpp:    __m128i match128     = _mm_set1_epi16(this->w_match);
bandedSWA.cpp:    __m128i mismatch128  = _mm_set1_epi16(this->w_mismatch);
bandedSWA.cpp:    __m128i w_ambig_128  = _mm_set1_epi16(this->w_ambig);   // ambig penalty
bandedSWA.cpp:    __m128i e_del128    = _mm_set1_epi16(this->e_del);
bandedSWA.cpp:    __m128i oe_del128   = _mm_set1_epi16(this->o_del + this->e_del);
bandedSWA.cpp:    __m128i e_ins128    = _mm_set1_epi16(this->e_ins);
bandedSWA.cpp:    __m128i oe_ins128   = _mm_set1_epi16(this->o_ins + this->e_ins);
bandedSWA.cpp:    minq -= 1; // for gscore
bandedSWA.cpp:    __m128i gscore = _mm_set1_epi16(-1);
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:        prof[DP3][0] += __rdtsc() - tim1;
bandedSWA.cpp:        // Z-score
bandedSWA.cpp:        prof[DP1][0] += __rdtsc() - tim1;
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        prof[DP2][0] += __rdtsc() - tim1;
bandedSWA.cpp:    prof[DP][0] += __rdtsc() - tim;
bandedSWA.cpp:/* SSE2 - 8 bit version */
bandedSWA.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH8 - 1)/SIMD_WIDTH8 ) * SIMD_WIDTH8;
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsLen(pairArray + first, last - first, myTempArray, myHist, myHistb);
bandedSWA.cpp:        __m128i eb_ins128 = _mm_set1_epi8(eb - o_ins);
bandedSWA.cpp:        __m128i eb_del128 = _mm_set1_epi8(eb - o_del);
bandedSWA.cpp://--------------------
bandedSWA.cpp://-------------------
bandedSWA.cpp://------------------------
bandedSWA.cpp:                // __m128i h1_128 = _mm_load_si128((__m128i *) (H1 + (k-1) * SIMD_WIDTH8));
bandedSWA.cpp://------------------------
bandedSWA.cpp:#if SORT_PAIRS       // disbaled in bwa-mem2 (only used in separate benchmark bsw code)
bandedSWA.cpp:            sortPairsId(pairArray + first, first, last - first, myTempArray);
bandedSWA.cpp:    setupTicks = st2 - st1;
bandedSWA.cpp:    sort1Ticks = st3 - st2;
bandedSWA.cpp:    swTicks = st4 - st3;
bandedSWA.cpp:    sort2Ticks = st5 - st4;
bandedSWA.cpp:    __m128i match128     = _mm_set1_epi8(this->w_match);
bandedSWA.cpp:    __m128i mismatch128  = _mm_set1_epi8(this->w_mismatch);
bandedSWA.cpp:    __m128i w_ambig_128  = _mm_set1_epi8(this->w_ambig);    // ambig penalty
bandedSWA.cpp:    __m128i e_del128    = _mm_set1_epi8(this->e_del);
bandedSWA.cpp:    __m128i oe_del128   = _mm_set1_epi8(this->o_del + this->e_del);
bandedSWA.cpp:    __m128i e_ins128    = _mm_set1_epi8(this->e_ins);
bandedSWA.cpp:    __m128i oe_ins128   = _mm_set1_epi8(this->o_ins + this->e_ins);
bandedSWA.cpp:    minq -= 1; // for gscore
bandedSWA.cpp:    __m128i gscore = _mm_set1_epi8(-1);
bandedSWA.cpp:        if (beg < i - w) beg = i - w;
bandedSWA.cpp:        prof[DP3][0] += __rdtsc() - tim1;
bandedSWA.cpp:        // Z-score
bandedSWA.cpp:        prof[DP1][0] += __rdtsc() - tim1;
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        for (l = end; l >= beg; l--)
bandedSWA.cpp:        prof[DP2][0] += __rdtsc() - tim1;
bandedSWA.cpp:    prof[DP][0] += __rdtsc() - tim;
Binary file memcpy_bwamem.o matches
bntseq.cpp:	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5 /*'-'*/, 4, 4,
bntseq.cpp:		err_fprintf(fp, "%lld %d %u\n", (long long)bns->l_pac, bns->n_seqs, bns->seed);
bntseq.cpp:		for (i = 0; i != bns->n_seqs; ++i)
bntseq.cpp:			bntann1_t *p = bns->anns + i;
bntseq.cpp:			err_fprintf(fp, "%d %s", p->gi, p->name);
bntseq.cpp:			if (p->anno[0])
bntseq.cpp:				err_fprintf(fp, " %s\n", p->anno);
bntseq.cpp:			err_fprintf(fp, "%lld %d %d\n", (long long)p->offset, p->len, p->n_ambs);
bntseq.cpp:		err_fprintf(fp, "%lld %d %u\n", (long long)bns->l_pac, bns->n_seqs, bns->n_holes);
bntseq.cpp:		for (i = 0; i != bns->n_holes; ++i)
bntseq.cpp:			bntamb1_t *p = bns->ambs + i;
bntseq.cpp:			err_fprintf(fp, "%lld %d %c\n", (long long)p->offset, p->len, p->amb);
bntseq.cpp:		// scanres = fscanf(fp, "%lld%d%u", &xx, &bns->n_seqs, &bns->seed);	// bns->n_seqs and bns->seed read from ann_file
bntseq.cpp:		scanres = fscanf(fp, "%lld%d%u", &xx, &bns->n_seqs, &bns_seed);
bntseq.cpp:		bns->n_seqs_enc = encrypt_plaintext_integer_to_ciphertext(bns->n_seqs);
bntseq.cpp:		bns->seed_enc = encrypt_plaintext_integer_to_ciphertext(bns_seed);
bntseq.cpp:		printf("decrypt_ciphertext_to_plaintext_vector(xx_enc)[0]: %d, decrypt_ciphertext_to_plaintext_vector(bns->n_seqs_enc)[0]: %d, decrypt_ciphertext_to_plaintext_vector(bns->seed_enc)[0]: %d\n", decrypt_ciphertext_to_plaintext_vector(xx_enc)[0], decrypt_ciphertext_to_plaintext_vector(bns->n_seqs_enc)[0], decrypt_ciphertext_to_plaintext_vector(bns->seed_enc)[0]);
bntseq.cpp:		assert(operate_and_decrypt(bns->n_seqs_enc, "-", 0) >= 0 && operate_and_decrypt(bns->n_seqs_enc, "-", INT_MAX) <= 0);
bntseq.cpp:		// assert(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(bns->n_seqs_enc, encode_integer_to_plaintext(0)))[0]>=0 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(bns->n_seqs_enc,encode_integer_to_plaintext(INT_MAX)))[0]<=0);
bntseq.cpp:		bns->l_pac = xx;
bntseq.cpp:		bns->l_pac_enc = xx_enc;
bntseq.cpp:		cout << "bns->n_seqs: " << bns->n_seqs << endl;
bntseq.cpp:		bns->anns = (bntann1_t *)calloc(bns->n_seqs, sizeof(bntann1_t));
bntseq.cpp:		assert(bns->anns != NULL);
bntseq.cpp:		for (i = 0; i < decrypt_ciphertext_to_plaintext_vector(bns->n_seqs_enc)[0]; ++i)
bntseq.cpp:			cout<<"-----------------------------------------------------"<<endl;
bntseq.cpp:			bntann1_t *p = &bns->anns[i];
bntseq.cpp:			// cout << "1 p->name_enc.size(): " << p->name_enc.size() << endl;
bntseq.cpp:			p->gi = gi;
bntseq.cpp:			p->gi_enc = encrypt_plaintext_integer_to_ciphertext(gi);
bntseq.cpp:				if(h==sizeof(str)-1)
bntseq.cpp:			// cout << "3 p->name_enc.size(): " << p->name_enc.size() << endl;
bntseq.cpp:			p->name = strdup(str);
bntseq.cpp:			printf("p->name: %s; sizeof(p->name): %d\n", p->name, sizeof(p->name));
bntseq.cpp:			// p->name_enc=vecCT(1,0);
bntseq.cpp:			// printf("&p->name_enc: %p\n",&p->name_enc);
bntseq.cpp:			// cout<<"4 p->name_enc.size(): "<<p->name_enc.size()<<endl; //<<"; strlen_enc(p->name_enc): "<<strlen_enc(p->name_enc)<<endl;
bntseq.cpp:			p->name_enc.resize(0);
bntseq.cpp:			strdup_enc(str_enc, p->name_enc);						// str_enc has 0/NULL at end
bntseq.cpp:			cout << "p->name_enc.size(): " << p->name_enc.size() << endl; //<<"; strlen_enc(p->name_enc): "<<strlen_enc(p->name_enc)<<endl;
bntseq.cpp:			printf("convert_ciphertext_vector_to_plaintext_string(p->name_enc): %s\n", convert_ciphertext_vector_to_plaintext_string(p->name_enc));
bntseq.cpp:			// p->name_enc.resize(str_enc.size()); // p->name_enc.shrink_to_fit();
bntseq.cpp:			// 	p->name_enc[i]=str_enc[i];
bntseq.cpp:			// while (q - str < sizeof(str) - 1 && (c = fgetc(fp)) != '\n' && c != EOF) *q++ = c;
bntseq.cpp:			// extra -1 because str_enc.size()=strlen(str)+1, due to extra enc('\n')
bntseq.cpp:			while (i_comment < strlen_enc(str_enc) - 1 && compare_enc((c_enc = encrypt_plaintext_integer_to_ciphertext(fgetc(fp))), '\n') == 0 && compare_enc(c_enc, EOF) == 0)
bntseq.cpp:			// if (q - str > 1 && strcmp(str, " (null)") != 0) p->anno = strdup(str + 1); // skip leading space
bntseq.cpp:			// else p->anno = strdup("");
bntseq.cpp:			// if(i_comment>1 &&  strcmp_enc(str_enc," (null)")!=0 ) strdup_enc(str_enc_2,p->anno_enc);
bntseq.cpp:				assign_string_to_vecCT(p->anno_enc, str + 1, -1);
bntseq.cpp:			// else assign_string_to_vecCT(p->anno_enc,"",-1);
bntseq.cpp:			p->len = p_len;
bntseq.cpp:			p->len_enc = encrypt_plaintext_integer_to_ciphertext(p_len);
bntseq.cpp:			p->n_ambs = p_n_ambs;
bntseq.cpp:			p->n_ambs_enc = encrypt_plaintext_integer_to_ciphertext(p_n_ambs);
bntseq.cpp:			p->offset = xx;
bntseq.cpp:			p->offset_enc = xx_enc;
bntseq.cpp:		bns->n_holes_enc = encrypt_plaintext_integer_to_ciphertext(n_holes);
bntseq.cpp:		// assert(bns->n_holes >= 0 && bns->n_holes <= INT_MAX);
bntseq.cpp:		assert(decrypt_ciphertext_to_plaintext_vector(bns->n_holes_enc)[0] >= 0 && operate_and_decrypt(bns->n_holes_enc, "-", INT_MAX) <= 0);
bntseq.cpp:		// xassert(l_pac == bns->l_pac && n_seqs == bns->n_seqs, "inconsistent .ann and .amb files.");
bntseq.cpp:		xassert(compare_enc(l_pac_enc, bns->l_pac_enc) && compare_enc(n_seqs_enc, bns->n_seqs_enc), "inconsistent .ann and .amb files.");
bntseq.cpp:		if (compare_enc(bns->n_holes_enc, 0) != 0)
bntseq.cpp:			// bns->ambs = (bntamb1_t*)calloc(bns->n_holes, sizeof(bntamb1_t));
bntseq.cpp:			bns->ambs = (bntamb1_t *)calloc(decrypt_ciphertext_to_plaintext_vector(bns->n_holes_enc)[0], sizeof(bntamb1_t));
bntseq.cpp:			assert(bns->ambs != NULL);
bntseq.cpp:			bns->ambs = 0;
bntseq.cpp:		for (i = 0; operate_and_decrypt(bns->n_holes_enc, "-", i) > 0; ++i)
bntseq.cpp:			bntamb1_t *p = bns->ambs + i;
bntseq.cpp:			p->len_enc = encrypt_plaintext_integer_to_ciphertext(p_len);
bntseq.cpp:			// p->offset = xx;
bntseq.cpp:			// p->amb = str[0];
bntseq.cpp:			p->offset_enc = xx_enc;
bntseq.cpp:			p->amb_enc = str_enc[0];
bntseq.cpp:		bns->fp_pac = xopen(pac_filename, "rb");
bntseq.cpp:// idx->bns = bns_restore(prefix);
bntseq.cpp:bntseq_t *bns_restore(const char *prefix) // prefix: ../../input-datasets/fmi/broad
bntseq.cpp:		for (i = 0; operate_and_decrypt(bns->n_seqs_enc, "-", i) > 0; ++i)
bntseq.cpp:			k = kh_put(str, h, bns->anns[i].name, &absent);
bntseq.cpp:						bns->anns[kh_val(h, k)].is_alt = 1;
bntseq.cpp:		if (bns->fp_pac)
bntseq.cpp:			err_fclose(bns->fp_pac);
bntseq.cpp:		free(bns->ambs);
bntseq.cpp:		for (i = 0; i < bns->n_seqs; ++i)
bntseq.cpp:			free(bns->anns[i].name);
bntseq.cpp:			free(bns->anns[i].anno);
bntseq.cpp:		free(bns->anns);
bntseq.cpp:	if (bns->n_seqs == *m_seqs)
bntseq.cpp:		bns->anns = (bntann1_t *)realloc(bns->anns, *m_seqs * sizeof(bntann1_t));
bntseq.cpp:		assert(bns->anns != NULL);
bntseq.cpp:	p = bns->anns + bns->n_seqs;
bntseq.cpp:	p->name = strdup((char *)seq->name.s);
bntseq.cpp:	p->anno = seq->comment.l > 0 ? strdup((char *)seq->comment.s) : strdup("(null)");
bntseq.cpp:	p->gi = 0;
bntseq.cpp:	p->len = seq->seq.l;
bntseq.cpp:	p->offset = (bns->n_seqs == 0) ? 0 : (p - 1)->offset + (p - 1)->len;
bntseq.cpp:	p->n_ambs = 0;
bntseq.cpp:	for (i = lasts = 0; i < seq->seq.l; ++i)
bntseq.cpp:		int c = nst_nt4_table[(int)seq->seq.s[i]];
bntseq.cpp:			if (lasts == seq->seq.s[i])
bntseq.cpp:				++(*q)->len;
bntseq.cpp:				if (bns->n_holes == *m_holes)
bntseq.cpp:					bns->ambs = (bntamb1_t *)realloc(bns->ambs, (*m_holes) * sizeof(bntamb1_t));
bntseq.cpp:				*q = bns->ambs + bns->n_holes;
bntseq.cpp:				(*q)->len = 1;
bntseq.cpp:				(*q)->offset = p->offset + i;
bntseq.cpp:				(*q)->amb = seq->seq.s[i];
bntseq.cpp:				++p->n_ambs;
bntseq.cpp:				++bns->n_holes;
bntseq.cpp:		lasts = seq->seq.s[i];
bntseq.cpp:			if (bns->l_pac == *m_pac)
bntseq.cpp:				memset(pac + bns->l_pac / 4, 0, (*m_pac - bns->l_pac) / 4);
bntseq.cpp:			_set_pac(pac, bns->l_pac, c);
bntseq.cpp:			++bns->l_pac;
bntseq.cpp:	++bns->n_seqs;
bntseq.cpp:	int64_t ret = -1, m_pac, l;
bntseq.cpp:	bns->seed = 11; // fixed seed for random generator
bntseq.cpp:	srand48(bns->seed);
bntseq.cpp:	bns->anns = (bntann1_t *)calloc(m_seqs, sizeof(bntann1_t));
bntseq.cpp:	assert(bns->anns != NULL);
bntseq.cpp:	bns->ambs = (bntamb1_t *)calloc(m_holes, sizeof(bntamb1_t));
bntseq.cpp:	assert(bns->ambs != NULL);
bntseq.cpp:	q = bns->ambs;
bntseq.cpp:		m_pac = (bns->l_pac * 2 + 3) / 4 * 4;
bntseq.cpp:		memset(pac + (bns->l_pac + 3) / 4, 0, (m_pac - (bns->l_pac + 3) / 4 * 4) / 4);
bntseq.cpp:		for (l = bns->l_pac - 1; l >= 0; --l, ++bns->l_pac)
bntseq.cpp:			_set_pac(pac, bns->l_pac, 3 - _get_pac(pac, l));
bntseq.cpp:	ret = bns->l_pac;
bntseq.cpp:		err_fwrite(pac, 1, (bns->l_pac >> 2) + ((bns->l_pac & 3) == 0 ? 0 : 1), fp);
bntseq.cpp:		if (bns->l_pac % 4 == 0)
bntseq.cpp:		ct = bns->l_pac % 4;
bntseq.cpp:		fprintf(stderr, "Usage: bwa fa2pac [-f] <in.fasta> [<out.prefix>]\n");
bntseq.cpp:	if (pos_f >= bns->l_pac)
bntseq.cpp:		return -1;
bntseq.cpp:	right = bns->n_seqs;
bntseq.cpp:		if (pos_f >= bns->anns[mid].offset)
bntseq.cpp:			if (mid == bns->n_seqs - 1)
bntseq.cpp:			if (pos_f < bns->anns[mid + 1].offset)
bntseq.cpp:	if (rb < bns->l_pac && re > bns->l_pac)
bntseq.cpp:		return -2;
bntseq.cpp:	rid_e = rb < re ? bns_pos2rid(bns, bns_depos(bns, re - 1, &is_rev)) : rid_b;
bntseq.cpp:	return rid_b == rid_e ? rid_b : -1;
bntseq.cpp:	right = bns->n_holes;
bntseq.cpp:		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len)
bntseq.cpp:		else if (pos_f + len <= bns->ambs[mid].offset)
bntseq.cpp:			if (pos_f >= bns->ambs[mid].offset)
bntseq.cpp:				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len ? bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
bntseq.cpp:				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len ? bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
bntseq.cpp:		*len = end - beg;
bntseq.cpp:		seq = (uint8_t *)malloc(end - beg + 64);
bntseq.cpp:			int64_t beg_f = (l_pac << 1) - 1 - end;
bntseq.cpp:			int64_t end_f = (l_pac << 1) - 1 - beg;
bntseq.cpp:			for (k = end_f; k > beg_f; --k)
bntseq.cpp:				seq[l++] = 3 - _get_pac(pac, k);
bntseq.cpp:		*len = 0; // if bridging the forward-reverse boundary, return nothing
bntseq.cpp:	far_beg = bns->anns[*rid].offset;
bntseq.cpp:	far_end = far_beg + bns->anns[*rid].len;
bntseq.cpp:		far_beg = (bns->l_pac << 1) - far_end;
bntseq.cpp:		far_end = (bns->l_pac << 1) - tmp;
bntseq.cpp:	seq = bns_get_seq(bns->l_pac, pac, *beg, *end, &len);
bntseq.cpp:	if (seq == 0 || *end - *beg != len)
bntseq.cpp:	assert(seq && *end - *beg == len); // assertion failure should never happen
read_index_ele.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
read_index_ele.h:	uint8_t  *pac; // the actual 2-bit encoded reference sequences with 'N' converted to a random base
Binary file fastmap.o matches
Binary file bandedSWA.o matches
bwamem.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwamem.h:    int pen_unpaired;       // phred-scaled penalty for unpaired reads
bwamem.h:    int zdrop;              // Z-dropoff
bwamem.h:    int max_chain_gap;      // do not chain seed if it is max_chain_gap-bp away from the closest seed
bwamem.h:    int64_t chunk_size;         // process chunk_size-bp sequences in a batch
bwamem.h:    int max_matesw;         // perform maximally max_matesw rounds of mate-SW for each end
bwamem.h:    int n_comp:30, is_alt:2; // number of sub-alignments chained together
bwamem.h:    int failed;      // non-zero if the orientation is not supported by sufficient data
bwamem.h:    int64_t pos;     // forward strand 5'-end mapping position
bwamem.h: * In the paired-end mode (i.e. MEM_F_PE is set in $opt->flag), query
bwamem.h: * sequences must be interleaved: $n must be an even number and the 2i-th
bwamem.h: * sequence and the (2i+1)-th sequence constitute a read pair. In this
bwamem.h: * @param bwt    FM-index of the reference sequence
bwamem.h: * @param pac    2-bit encoded reference
bwamem.h: * @param pes0   insert-size info; if NULL, infer from data; if not NULL, it should be an array with 4 elements,
bwamem.h: * Generate CIGAR and forward-strand position from alignment region
bwamem.h: * @param pac    2-bit encoded reference
bwamem.h: * @return       CIGAR, strand, mapping quality and forward-strand position
bwamem.h: * This function can be called after mem_align1(), as long as paired-end
bwamem.h: * @param regs   region array of size $n; 2i-th and (2i+1)-th elements constitute a pair
profiling.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
profiling.cpp:    fprintf(stderr, "\t--WORKER_SAM avg: %0.2lf, (%0.2lf, %0.2lf)\n",
profiling.cpp:        fprintf(stderr, "There is a discrepancy re-allocs, plz rectify!!\n");
profiling.cpp:        fprintf(stderr, "\n\tTotal re-allocs: %d out of total requests: %d, Rate: %0.2f\n",
profiling.cpp:    fprintf(stderr, "\tAvg. FM-index traversal per get_sa_entry(): avg: %lf, max: %lf, min: %lf\n",
profiling.cpp:    fprintf(stderr, "\tLeft 16-bit time avg: %0.2lf, (%0.2lf, %0.2lf)\n",
profiling.cpp:    fprintf(stderr, "\tLeft 8-bit time avg: %0.2lf, (%0.2lf, %0.2lf)\n",
profiling.cpp:    fprintf(stderr, "\tRight 16-bit time avg: %0.2lf, (%0.2lf, %0.2lf)\n",
profiling.cpp:    fprintf(stderr, "\tRight 8-bit time avg: %0.2lf, (%0.2lf, %0.2lf)\n",
sais.h: * sais.hxx for sais-lite
sais.h: * Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.
sais.h:  else { for(i = 0; i < k; ++i) { sum += C[i]; B[i] = sum - C[i]; } }
sais.h:  j = n - 1;
sais.h:  --j;
sais.h:      if((c0 = T[j]) != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      assert(i < (b - SA));
sais.h:      --j;
sais.h:  for(i = n - 1, b = SA + B[c1 = 0]; 0 <= i; --i) {
sais.h:      if((c0 = T[j]) != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      assert((b - SA) <= i);
sais.h:      --j;
sais.h:      *--b = (T[j] > c1) ? ~(j + 1) : j;
sais.h:  i = n - 1; j = n - 1; c0 = T[n - 1];
sais.h:  do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) >= c1));
sais.h:    do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) <= c1));
sais.h:      SA[m + ((i + 1) >> 1)] = j - i; j = i + 1;
sais.h:      do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) >= c1));
sais.h:  j = n - 1;
sais.h:  --j;
sais.h:      if(n <= j) { d += 1; j -= n; }
sais.h:      if((c0 = T[j]) != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      assert(i < (b - SA));
sais.h:      --j;
sais.h:  for(i = n - 1; 0 <= i; --i) {
sais.h:        for(j = i - 1; SA[j] < n; --j) { }
sais.h:        SA[j] -= n;
sais.h:  for(i = n - 1, d += 1, b = SA + B[c1 = 0]; 0 <= i; --i) {
sais.h:      if(n <= j) { d += 1; j -= n; }
sais.h:      if((c0 = T[j]) != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      assert((b - SA) <= i);
sais.h:      --j;
sais.h:      *--b = (t & 1) ? ~(j + 1) : j;
sais.h:    for(i = m - 1, d = name + 1; 0 <= i; --i) {
sais.h:      if(n <= (j = SA[i])) { j -= n; --d; }
sais.h:      if(n <= (j = SA[i])) { j -= n; SA[i] = j; }
sais.h:  b = SA + B[c1 = T[j = n - 1]];
sais.h:  *b++ = ((0 < j) && (T[j - 1] < c1)) ? ~j : j;
sais.h:      if((c0 = T[--j]) != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      *b++ = ((0 < j) && (T[j - 1] < c1)) ? ~j : j;
sais.h:  for(i = n - 1, b = SA + B[c1 = 0]; 0 <= i; --i) {
sais.h:      if((c0 = T[--j]) != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      *--b = ((j == 0) || (T[j - 1] > c1)) ? ~j : j;
sais.h:  index_type i, j, pidx = -1;
sais.h:  b = SA + B[c1 = T[j = n - 1]];
sais.h:  *b++ = ((0 < j) && (T[j - 1] < c1)) ? ~j : j;
sais.h:      SA[i] = ~((index_type)(c0 = T[--j]));
sais.h:      if(c0 != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      *b++ = ((0 < j) && (T[j - 1] < c1)) ? ~j : j;
sais.h:  for(i = n - 1, b = SA + B[c1 = 0]; 0 <= i; --i) {
sais.h:      SA[i] = (c0 = T[--j]);
sais.h:      if(c0 != c1) { B[c1] = b - SA; b = SA + B[c1 = c0]; }
sais.h:      *--b = ((0 < j) && (T[j - 1] > c1)) ? ~((index_type)T[j - 1]) : j;
sais.h:  b = SA + n - 1; i = n - 1; j = n; m = 0; c0 = T[n - 1];
sais.h:  do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) >= c1));
sais.h:    do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) <= c1));
sais.h:      *b = j; b = SA + --B[c1]; j = i; ++m; assert(B[c1] != (n - 1));
sais.h:      do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) >= c1));
sais.h:  SA[n - 1] = 0;
sais.h:        if(D == 0) { return std::make_pair(-2, -2); }
sais.h:        bucketB_type D = B - k * 2;
sais.h:  /* put all left-most S characters into their buckets */
sais.h:    i = m - 1, j = n, p = SA[m - 1], c1 = T[p];
sais.h:      while(q < j) { SA[--j] = 0; }
sais.h:        SA[--j] = p;
sais.h:        if(--i < 0) { break; }
sais.h:    while(0 < j) { SA[--j] = 0; }
sais.h:/* find the suffix array SA of T[0..n-1] in {0..k}^n
sais.h:     sort all the S-substrings */
sais.h:    if(Cp == 0) { return -2; }
sais.h:      B = SA + (n + fs - k);
sais.h:      if(Bp == 0) { delete[] Cp; return -2; }
sais.h:    C = SA + (n + fs - k);
sais.h:    if(k <= (fs - k)) {
sais.h:      B = C - k;
sais.h:      if(Bp == 0) { return -2; }
sais.h:    if(Cp == 0) { return -2; }
sais.h:    if(flags & 1) { flags |= ((k * 2) <= (fs - k)) ? 32 : 16; }
sais.h:    else if((flags == 0) && ((k * 2) <= (fs - k * 2))) { flags |= 32; }
sais.h:    return -2;
sais.h:    newfs = (n + fs) - (m * 2);
sais.h:      if((k + name) <= newfs) { newfs -= k; }
sais.h:    for(i = m + (n >> 1) - 1, j = m - 1; m <= i; --i) {
sais.h:      if(SA[i] != 0) { RA[j--] = SA[i] - 1; }
sais.h:    if(suffixsort(RA, SA, newfs, m, name, false) != 0) { if(flags & 1) { delete[] Cp; } return -2; }
sais.h:    i = n - 1; j = m - 1; c0 = T[n - 1];
sais.h:    do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) >= c1));
sais.h:      do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) <= c1));
sais.h:        RA[j--] = i + 1;
sais.h:        do { c1 = c0; } while((0 <= --i) && ((c0 = T[i]) >= c1));
sais.h:      if(Cp == 0) { return -2; }
sais.h:      if(Bp == 0) { if(flags & (1 | 4)) { delete[] Cp; } return -2; }
sais.h: * @param T[0..n-1] The input string. (random access iterator)
sais.h: * @param SA[0..n-1] The output array of suffixes. (random access iterator)
sais.h: * @return 0 if no error occurred, -1 or -2 otherwise.
sais.h:  if((n < 0) || (k <= 0)) { return -1; }
sais.h: * @brief Constructs the burrows-wheeler transformed string of a given string in linear time.
sais.h: * @param T[0..n-1] The input string. (random access iterator)
sais.h: * @param U[0..n-1] The output string. (random access iterator)
sais.h: * @param A[0..n-1] The temporary array. (random access iterator)
sais.h: * @return The primary index if no error occurred, -1 or -2 otherwise.
sais.h:  if((n < 0) || (k <= 0)) { return -1; }
sais.h:    U[0] = T[n - 1];
bwamem_extra.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwamem_extra.cpp:	bwtintv_v *sub;     // sub-matches inside the longest match; temporary
bwamem_extra.cpp:	itr->bwt = bwt;
bwamem_extra.cpp:	itr->tmpvec[0] = (bwtintv_v*) calloc(1, sizeof(bwtintv_v));
bwamem_extra.cpp:	itr->tmpvec[1] = (bwtintv_v*) calloc(1, sizeof(bwtintv_v));
bwamem_extra.cpp:	itr->matches   = (bwtintv_v*) calloc(1, sizeof(bwtintv_v));
bwamem_extra.cpp:	itr->sub       = (bwtintv_v*) calloc(1, sizeof(bwtintv_v));
bwamem_extra.cpp:	itr->min_intv = 1;
bwamem_extra.cpp:	itr->max_len  = INT_MAX;
bwamem_extra.cpp:	itr->max_intv = 0;
bwamem_extra.cpp:	free(itr->tmpvec[0]->a); free(itr->tmpvec[0]);
bwamem_extra.cpp:	free(itr->tmpvec[1]->a); free(itr->tmpvec[1]);
bwamem_extra.cpp:	free(itr->matches->a);   free(itr->matches);
bwamem_extra.cpp:	free(itr->sub->a);       free(itr->sub);
bwamem_extra.cpp:	itr->query = query;
bwamem_extra.cpp:	itr->start = 0;
bwamem_extra.cpp:	itr->len = len;
bwamem_extra.cpp:	itr->min_intv = min_intv;
bwamem_extra.cpp:	itr->max_len  = max_len;
bwamem_extra.cpp:	itr->max_intv = max_intv;
bwamem_extra.cpp:	itr->tmpvec[0]->n = itr->tmpvec[1]->n = itr->matches->n = itr->sub->n = 0;
bwamem_extra.cpp:	if (itr->start >= itr->len || itr->start < 0) return 0;
bwamem_extra.cpp:	while (itr->start < itr->len && itr->query[itr->start] > 3) ++itr->start; // skip ambiguous bases
bwamem_extra.cpp:	if (itr->start == itr->len) return 0;
bwamem_extra.cpp:	ori_start = itr->start;
bwamem_extra.cpp:	itr->start = bwt_smem1a(itr->bwt, itr->len, itr->query, ori_start, itr->min_intv, itr->max_intv, itr->matches, itr->tmpvec); // search for SMEM
bwamem_extra.cpp:	return itr->matches;
bwamem_extra.cpp:	return -1;
bwamem_extra.cpp:	cnt = (int *) calloc(a->n, sizeof(int));
bwamem_extra.cpp:	has_alt = (char *) calloc(a->n, 1);
bwamem_extra.cpp:	for (i = 0, tot = 0; i < a->n; ++i) {
bwamem_extra.cpp:		r = get_pri_idx(opt->XA_drop_ratio, a->a, i);
bwamem_extra.cpp:			if (a->a[i].is_alt) has_alt[r] = 1;
bwamem_extra.cpp:	aln = (kstring_t*) calloc(a->n, sizeof(kstring_t));
bwamem_extra.cpp:	for (i = 0; i < a->n; ++i) {
bwamem_extra.cpp:		if ((r = get_pri_idx(opt->XA_drop_ratio, a->a, i)) < 0) continue;
bwamem_extra.cpp:		if (cnt[r] > opt->max_XA_hits_alt || (!has_alt[r] && cnt[r] > opt->max_XA_hits)) continue;
bwamem_extra.cpp:		t = mem_reg2aln(opt, bns, pac, l_query, query, &a->a[i]);
bwamem_extra.cpp:		kputs(bns->anns[t.rid].name, &str);
bwamem_extra.cpp:		kputc(',', &str); kputc("+-"[t.is_rev], &str); kputl(t.pos + 1, &str);
bwamem_extra.cpp:		//	char *tt = strstr(str.s, "-161728"); // delete,debug
bwamem_extra.cpp:	XA = (char**) calloc(a->n, sizeof(char*));
bwamem_extra.cpp:	for (k = 0; k < a->n; ++k)
bwtindex.cpp:		fprintf(stderr, "Usage: bwa-mem2 index [-p prefix] <in.fasta>\n");
bwtindex.cpp:		fprintf(stderr, "%.2f sec\n", (float)(clock() - t) / CLOCKS_PER_SEC);
bwtindex.cpp:        fmi->build_index();
bwamem_pair.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwamem_pair.cpp:    p2 = r1 == r2? b2 : (l_pac<<1) - 1 - b2; // p2 is the coordinate of read 2 on the read 1 strand
bwamem_pair.cpp:    *dist = p2 > b1? p2 - b1 : b1 - p2;
bwamem_pair.cpp:    for (j = 1; j < r->n; ++j) { // choose unique alignment
bwamem_pair.cpp:        int b_max = r->a[j].qb > r->a[0].qb? r->a[j].qb : r->a[0].qb;
bwamem_pair.cpp:        int e_min = r->a[j].qe < r->a[0].qe? r->a[j].qe : r->a[0].qe;
bwamem_pair.cpp:            int min_l = r->a[j].qe - r->a[j].qb < r->a[0].qe - r->a[0].qb? r->a[j].qe - r->a[j].qb : r->a[0].qe - r->a[0].qb;
bwamem_pair.cpp:            if (e_min - b_max >= min_l * opt->mask_level) break; // significant overlap
bwamem_pair.cpp:    return j < r->n? r->a[j].score : opt->min_seed_len * opt->a;
bwamem_pair.cpp:        if (r[0]->n == 0 || r[1]->n == 0) continue;
bwamem_pair.cpp:        if (cal_sub(opt, r[0]) > MIN_RATIO * r[0]->a[0].score) continue;
bwamem_pair.cpp:        if (cal_sub(opt, r[1]) > MIN_RATIO * r[1]->a[0].score) continue;
bwamem_pair.cpp:        if (r[0]->a[0].rid != r[1]->a[0].rid) continue; // not on the same chr
bwamem_pair.cpp:        dir = mem_infer_dir(l_pac, r[0]->a[0].rb, r[1]->a[0].rb, &is);
bwamem_pair.cpp:        if (is && is <= opt->max_ins) kv_push(uint64_t, isize[dir], is);
bwamem_pair.cpp:        if (q->n < MIN_DIR_CNT) {
bwamem_pair.cpp:            r->failed = 1;
bwamem_pair.cpp:            free(q->a);
bwamem_pair.cpp:        ks_introsort_64(q->n, q->a);
bwamem_pair.cpp:        p25 = q->a[(int)(.25 * q->n + .499)];
bwamem_pair.cpp:        p50 = q->a[(int)(.50 * q->n + .499)];
bwamem_pair.cpp:        p75 = q->a[(int)(.75 * q->n + .499)];
bwamem_pair.cpp:        r->low  = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);
bwamem_pair.cpp:        if (r->low < 1) r->low = 1;
bwamem_pair.cpp:        r->high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);
bwamem_pair.cpp:        fprintf(stderr, "[0000][PE] low and high boundaries for computing mean and std.dev: (%d, %d)\n", r->low, r->high);
bwamem_pair.cpp:        for (i = x = 0, r->avg = 0; i < q->n; ++i)
bwamem_pair.cpp:            if (q->a[i] >= r->low && q->a[i] <= r->high)
bwamem_pair.cpp:                r->avg += q->a[i], ++x;
bwamem_pair.cpp:        r->avg /= x;
bwamem_pair.cpp:        for (i = 0, r->std = 0; i < q->n; ++i)
bwamem_pair.cpp:            if (q->a[i] >= r->low && q->a[i] <= r->high)
bwamem_pair.cpp:                r->std += (q->a[i] - r->avg) * (q->a[i] - r->avg);
bwamem_pair.cpp:        r->std = sqrt(r->std / x);
bwamem_pair.cpp:        fprintf(stderr, "[0000][PE] mean and std.dev: (%.2f, %.2f)\n", r->avg, r->std);
bwamem_pair.cpp:        r->low  = (int)(p25 - MAPPING_BOUND * (p75 - p25) + .499);
bwamem_pair.cpp:        r->high = (int)(p75 + MAPPING_BOUND * (p75 - p25) + .499);
bwamem_pair.cpp:        if (r->low  > r->avg - MAX_STDDEV * r->std) r->low  = (int)(r->avg - MAX_STDDEV * r->std + .499);
bwamem_pair.cpp:        if (r->high < r->avg + MAX_STDDEV * r->std) r->high = (int)(r->avg + MAX_STDDEV * r->std + .499);
bwamem_pair.cpp:        if (r->low < 1) r->low = 1;
bwamem_pair.cpp:        fprintf(stderr, "[0000][PE] low and high boundaries for proper pairs: (%d, %d)\n", r->low, r->high);
bwamem_pair.cpp:        free(q->a);
bwamem_pair.cpp:    int64_t l_pac = bns->l_pac;
bwamem_pair.cpp:    int i, r, skip[4], n = 0, rid = -1;
bwamem_pair.cpp:    for (i = 0; i < ma->n; ++i) { // check which orinentation has been found
bwamem_pair.cpp:        r = mem_infer_dir(l_pac, a->rb, ma->a[i].rb, &dist);
bwamem_pair.cpp:            for (i = 0; i < l_ms; ++i) rev[l_ms - 1 - i] = ms[i] < 4? 3 - ms[i] : 4;
bwamem_pair.cpp:            rb = is_larger? a->rb + pes[r].low : a->rb - pes[r].high;
bwamem_pair.cpp:            re = (is_larger? a->rb + pes[r].high: a->rb - pes[r].low) + l_ms; // if on the same strand, end position should be larger to make room for the seq length
bwamem_pair.cpp:            rb = (is_larger? a->rb + pes[r].low : a->rb - pes[r].high) - l_ms; // similarly on opposite strands
bwamem_pair.cpp:            re = is_larger? a->rb + pes[r].high: a->rb - pes[r].low;
bwamem_pair.cpp:        if (a->rid == rid && re - rb >= opt->min_seed_len) { // no funny things happening
bwamem_pair.cpp:            int tmp, xtra = KSW_XSUBO | KSW_XSTART | (l_ms * opt->a < 250? KSW_XBYTE : 0) | (opt->min_seed_len * opt->a);
bwamem_pair.cpp:            assert(ref !=0 && re - rb >= 0);
bwamem_pair.cpp:            aln = ksw_align2(l_ms, seq, re - rb, ref, 5,
bwamem_pair.cpp:                             opt->mat, opt->o_del, opt->e_del,
bwamem_pair.cpp:                             opt->o_ins, opt->e_ins, xtra, 0);
bwamem_pair.cpp:            if (aln.score >= opt->min_seed_len && aln.qb >= 0) { // something goes wrong if aln.qb < 0
bwamem_pair.cpp:                b.rid = a->rid;
bwamem_pair.cpp:                b.is_alt = a->is_alt;
bwamem_pair.cpp:                b.qb = is_rev? l_ms - (aln.qe + 1) : aln.qb;                                                                                                                                                                              
bwamem_pair.cpp:                b.qe = is_rev? l_ms - aln.qb : aln.qe + 1; 
bwamem_pair.cpp:                b.rb = is_rev? (l_pac<<1) - (rb + aln.te + 1) : rb + aln.tb;
bwamem_pair.cpp:                b.re = is_rev? (l_pac<<1) - (rb + aln.tb) : rb + aln.te + 1;
bwamem_pair.cpp:                b.secondary = -1;
bwamem_pair.cpp:                b.seedcov = (b.re - b.rb < b.qe - b.qb? b.re - b.rb : b.qe - b.qb) >> 1;
bwamem_pair.cpp:                for (i = 0; i < ma->n - 1; ++i) // find the insertion point
bwamem_pair.cpp:                    if (ma->a[i].score < b.score) break;
bwamem_pair.cpp:                for (i = ma->n - 1; i > tmp; --i) ma->a[i] = ma->a[i-1];
bwamem_pair.cpp:                ma->a[i] = b;
bwamem_pair.cpp:        if (n) ma->n = mem_sort_dedup_patch(opt, 0, 0, 0, ma->n, ma->a);
bwamem_pair.cpp:    int64_t l_pac = bns->l_pac;
bwamem_pair.cpp:            key.x = e->rb < l_pac? e->rb : (l_pac<<1) - 1 - e->rb; // forward position
bwamem_pair.cpp:            key.x = (uint64_t)e->rid<<32 | (key.x - bns->anns[e->rid].offset);
bwamem_pair.cpp:            key.y = (uint64_t)e->score << 32 | i << 2 | (e->rb >= l_pac)<<1 | r;
bwamem_pair.cpp:    y[0] = y[1] = y[2] = y[3] = -1;
bwamem_pair.cpp:            for (k = y[which]; k >= 0; --k) { // TODO: this is a O(n^2) solution in the worst case; remember to check if this loop takes a lot of time (I doubt)
bwamem_pair.cpp:                dist = (int64_t)v.a[i].x - v.a[k].x;
bwamem_pair.cpp:                ns = (dist - pes[dir].avg) / pes[dir].std;
bwamem_pair.cpp:                q = (int)((v.a[i].y>>32) + (v.a[k].y>>32) + .721 * log(2. * erfc(fabs(ns) * M_SQRT1_2)) * opt->a + .499); // .721 = 1/log(4)
bwamem_pair.cpp:                p->y = (uint64_t)k<<32 | i;
bwamem_pair.cpp:                p->x = (uint64_t)q<<32 | (hash_64(p->y ^ id<<8) & 0xffffffffU);
bwamem_pair.cpp:        int tmp = opt->a + opt->b;
bwamem_pair.cpp:        tmp = tmp > opt->o_del + opt->e_del? tmp : opt->o_del + opt->e_del;
bwamem_pair.cpp:        tmp = tmp > opt->o_ins + opt->e_ins? tmp : opt->o_ins + opt->e_ins;
bwamem_pair.cpp:        i = u.a[u.n-1].y >> 32; k = u.a[u.n-1].y << 32 >> 32;
bwamem_pair.cpp:        ret = u.a[u.n-1].x >> 32;
bwamem_pair.cpp:        *sub = u.n > 1? u.a[u.n-2].x>>32 : 0;
bwamem_pair.cpp:        for (i = (long)u.n - 2, *n_sub = 0; i >= 0; --i)
bwamem_pair.cpp:            if (*sub - (int)(u.a[i].x>>32) <= tmp) ++*n_sub;
bwamem_pair.cpp:    if (!(opt->flag & MEM_F_NO_RESCUE)) { // then perform SW for the best alignment
bwamem_pair.cpp:                if (a[i].a[j].score >= a[i].a[0].score  - opt->pen_unpaired)
bwamem_pair.cpp:            for (j = 0; j < b[i].n && j < opt->max_matesw; ++j) {
bwamem_pair.cpp:    if (opt->flag & MEM_F_PRIMARY5) {
bwamem_pair.cpp:        mem_reorder_primary5(opt->T, &a[0]);
bwamem_pair.cpp:        mem_reorder_primary5(opt->T, &a[1]);
bwamem_pair.cpp:    if (opt->flag&MEM_F_NOPAIRING) goto no_pairing;
bwamem_pair.cpp:    // pairing single-end hits
bwamem_pair.cpp:        // check if an end has multiple hits even after mate-SW
bwamem_pair.cpp:                if (a[i].a[j].secondary < 0 && a[i].a[j].score >= opt->T) break;
bwamem_pair.cpp:        score_un = a[0].a[0].score + a[1].a[0].score - opt->pen_unpaired;
bwamem_pair.cpp:        //q_pe = o && subo < o? (int)(MEM_MAPQ_COEF * (1. - (double)subo / o) * log(a[0].a[z[0]].seedcov + a[1].a[z[1]].seedcov) + .499) : 0;
bwamem_pair.cpp:        q_pe = raw_mapq(o - subo, opt->a);
bwamem_pair.cpp:        if (n_sub > 0) q_pe -= (int)(4.343 * log(n_sub+1) + .499);
bwamem_pair.cpp:        q_pe = (int)(q_pe * (1. - .5 * (a[0].a[0].frac_rep + a[1].a[0].frac_rep)) + .499);
bwamem_pair.cpp:                if (c[i]->secondary >= 0)
bwamem_pair.cpp:                    c[i]->sub = a[i].a[c[i]->secondary].score, c[i]->secondary = -2;
bwamem_pair.cpp:            q_se[0] = q_se[0] < raw_mapq(c[0]->score - c[0]->csub, opt->a)? q_se[0] : raw_mapq(c[0]->score - c[0]->csub, opt->a);
bwamem_pair.cpp:            q_se[1] = q_se[1] < raw_mapq(c[1]->score - c[1]->csub, opt->a)? q_se[1] : raw_mapq(c[1]->score - c[1]->csub, opt->a);
bwamem_pair.cpp:            if (k >= 0 && k < n_pri[i]) { // switch secondary and primary if both of them are non-ALT
bwamem_pair.cpp:                a[i].a[z[i]].secondary_all = -1;
bwamem_pair.cpp:        if (!(opt->flag & MEM_F_ALL)) {
bwamem_pair.cpp:                if (p->score < opt->T || p->secondary >= 0 || !p->is_alt) continue;
bwamem_pair.cpp:        int which = -1;
bwamem_pair.cpp:            if (a[i].a[0].score >= opt->T) which = 0;
bwamem_pair.cpp:            else if (n_pri[i] < a[i].n && a[i].a[n_pri[i]].score >= opt->T)
bwamem_pair.cpp:    if (!(opt->flag & MEM_F_NOPAIRING) && h[0].rid == h[1].rid && h[0].rid >= 0) { // if the top hits from the two ends constitute a proper pair, flag it.
bwamem_pair.cpp:        d = mem_infer_dir(bns->l_pac, a[0].a[0].rb, a[1].a[0].rb, &dist);
bwamem_pair.cpp:    //uint8_t *seqBufRef = mmc->seqBufLeftRef[tid*CACHE_LINE];
bwamem_pair.cpp:    //uint8_t *seqBufQer = mmc->seqBufLeftQer[tid*CACHE_LINE];
bwamem_pair.cpp:    // int64_t *wsize_buf = &(mmc->wsize_buf[tid]);
bwamem_pair.cpp:    //SeqPair *seqPairArray = mmc->seqPairArrayLeft128[tid];
bwamem_pair.cpp:    //int32_t *gar = (int32_t*) (mmc->seqPairArrayAux[tid]);
bwamem_pair.cpp:    // int64_t *wsize = &(mmc->wsize[tid]);
bwamem_pair.cpp:    if (!(opt->flag & MEM_F_NO_RESCUE)) { // then perform SW for the best alignment
bwamem_pair.cpp:                if (a[i].a[j].score >= a[i].a[0].score  - opt->pen_unpaired)
bwamem_pair.cpp:            for (j = 0; j < b[i].n && j < opt->max_matesw; ++j) {
bwamem_pair.cpp:        t = s[i], s[i] = s[l - 1 - i], s[l - 1 - i] = t;
bwamem_pair.cpp:    uint8_t *seqBufRef = mmc->seqBufLeftRef[tid*CACHE_LINE];
bwamem_pair.cpp:    uint8_t *seqBufQer = mmc->seqBufLeftQer[tid*CACHE_LINE];    
bwamem_pair.cpp:    SeqPair *seqPairArray = mmc->seqPairArrayLeft128[tid];
bwamem_pair.cpp:#if DEBUG    // orig function from bwa-mem -- for debugging purpose. Disabled by default.
bwamem_pair.cpp:                            opt->mat, opt->o_del, opt->e_del,
bwamem_pair.cpp:                            opt->o_ins, opt->e_ins, xtra, 0);       
bwamem_pair.cpp:    // tprof[SAM2][0] += __rdtsc() - tim;
bwamem_pair.cpp:        r->tb = r->qb = -1;
bwamem_pair.cpp:    int nthreads = 1; // no multi-threading here
bwamem_pair.cpp:    kswv *pwsw = new kswv(opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, opt->a, -1*opt->b, nthreads,
bwamem_pair.cpp:    // Shift 16-bit 
bwamem_pair.cpp:    for (int i=0; i<pcnt-pcnt8; i++)
bwamem_pair.cpp:        seqPairArray[pcnt + MAX_LINE_LEN - 1 - i] = seqPairArray[pcnt-i-1];
bwamem_pair.cpp:    pwsw->getScores8(seqPairArray, seqBufRef, seqBufQer, aln, pcnt8, nthreads, 0);
bwamem_pair.cpp:    pwsw->getScores16(seqPairArray + pcnt8 + MAX_LINE_LEN, seqBufRef, seqBufQer,
bwamem_pair.cpp:                      aln, pcnt-pcnt8, nthreads, 0);
bwamem_pair.cpp:    // Post-processing
bwamem_pair.cpp:    for (int i=0; i<pcnt-pcnt8; i++)
bwamem_pair.cpp:    pwsw->getScores16(seqPairArray + pos8, seqBufRef, seqBufQer, aln, pos16, nthreads, 1);
bwamem_pair.cpp:    pwsw->getScores8(seqPairArray, seqBufRef, seqBufQer, aln, pos8, nthreads, 1);
bwamem_pair.cpp:    int32_t *gar = (int32_t*) mmc->seqPairArrayAux[tid];
bwamem_pair.cpp:    if (!(opt->flag & MEM_F_NO_RESCUE)) { // then perform SW for the best alignment
bwamem_pair.cpp:                if (a[i].a[j].score >= a[i].a[0].score  - opt->pen_unpaired)
bwamem_pair.cpp:            for (j = 0; j < b[i].n && j < opt->max_matesw; ++j) {
bwamem_pair.cpp:    if (opt->flag & MEM_F_PRIMARY5) {
bwamem_pair.cpp:        mem_reorder_primary5(opt->T, &a[0]);
bwamem_pair.cpp:        mem_reorder_primary5(opt->T, &a[1]);
bwamem_pair.cpp:    if (opt->flag&MEM_F_NOPAIRING) goto no_pairing;
bwamem_pair.cpp:    // pairing single-end hits
bwamem_pair.cpp:        // check if an end has multiple hits even after mate-SW
bwamem_pair.cpp:                if (a[i].a[j].secondary < 0 && a[i].a[j].score >= opt->T) break;
bwamem_pair.cpp:        score_un = a[0].a[0].score + a[1].a[0].score - opt->pen_unpaired;
bwamem_pair.cpp:        //q_pe = o && subo < o? (int)(MEM_MAPQ_COEF * (1. - (double)subo / o) * log(a[0].a[z[0]].seedcov + a[1].a[z[1]].seedcov) + .499) : 0;
bwamem_pair.cpp:        q_pe = raw_mapq(o - subo, opt->a);
bwamem_pair.cpp:        if (n_sub > 0) q_pe -= (int)(4.343 * log(n_sub+1) + .499);
bwamem_pair.cpp:        q_pe = (int)(q_pe * (1. - .5 * (a[0].a[0].frac_rep + a[1].a[0].frac_rep)) + .499);
bwamem_pair.cpp:                if (c[i]->secondary >= 0)
bwamem_pair.cpp:                    c[i]->sub = a[i].a[c[i]->secondary].score, c[i]->secondary = -2;
bwamem_pair.cpp:            q_se[0] = q_se[0] < raw_mapq(c[0]->score - c[0]->csub, opt->a)? q_se[0] : raw_mapq(c[0]->score - c[0]->csub, opt->a);
bwamem_pair.cpp:            q_se[1] = q_se[1] < raw_mapq(c[1]->score - c[1]->csub, opt->a)? q_se[1] : raw_mapq(c[1]->score - c[1]->csub, opt->a);
bwamem_pair.cpp:            if (k >= 0 && k < n_pri[i]) { // switch secondary and primary if both of them are non-ALT
bwamem_pair.cpp:                a[i].a[z[i]].secondary_all = -1;
bwamem_pair.cpp:        if (!(opt->flag & MEM_F_ALL)) {
bwamem_pair.cpp:                if (p->score < opt->T || p->secondary >= 0 || !p->is_alt) continue;
bwamem_pair.cpp:        int which = -1;
bwamem_pair.cpp:            if (a[i].a[0].score >= opt->T) which = 0;
bwamem_pair.cpp:            else if (n_pri[i] < a[i].n && a[i].a[n_pri[i]].score >= opt->T)
bwamem_pair.cpp:    if (!(opt->flag & MEM_F_NOPAIRING) && h[0].rid == h[1].rid && h[0].rid >= 0) { // if the top hits from the two ends constitute a proper pair, flag it.
bwamem_pair.cpp:        d = mem_infer_dir(bns->l_pac, a[0].a[0].rb, a[1].a[0].rb, &dist);
bwamem_pair.cpp:    uint8_t *seqBufRef = mmc->seqBufLeftRef[tid*CACHE_LINE];
bwamem_pair.cpp:    uint8_t *seqBufQer = mmc->seqBufLeftQer[tid*CACHE_LINE];
bwamem_pair.cpp:    SeqPair *seqPairArray = mmc->seqPairArrayLeft128[tid];
bwamem_pair.cpp:    int32_t *gar = (int32_t*) (mmc->seqPairArrayAux[tid]);
bwamem_pair.cpp:    int64_t *wsize_pair = &(mmc->wsize[tid]);
bwamem_pair.cpp:    int64_t *wsize_buf_ref = &(mmc->wsize_buf_ref[tid*CACHE_LINE]);
bwamem_pair.cpp:    int64_t *wsize_buf_qer = &(mmc->wsize_buf_qer[tid*CACHE_LINE]);
bwamem_pair.cpp:    int64_t l_pac = bns->l_pac;
bwamem_pair.cpp:    int i, r, skip[4], rid = -1;
bwamem_pair.cpp:    for (i = 0; i < ma->n; ++i) { // check which orinentation has been found        
bwamem_pair.cpp:        r = mem_infer_dir(l_pac, a->rb, ma->a[i].rb, &dist);
bwamem_pair.cpp:        gar[gcnt + 3] = gar[gcnt + 2] = gar[gcnt + 1] = gar[gcnt + 0] = -1;
bwamem_pair.cpp:            gar[gcnt + r] = -1;
bwamem_pair.cpp:            for (i = 0; i < l_ms; ++i) rev[l_ms - 1 - i] = ms[i] < 4? 3 - ms[i] : 4;
bwamem_pair.cpp:            rb = is_larger? a->rb + pes[r].low : a->rb - pes[r].high;
bwamem_pair.cpp:            re = (is_larger? a->rb + pes[r].high: a->rb - pes[r].low) + l_ms; // if on the same strand, end position should be larger to make room for the seq length
bwamem_pair.cpp:            rb = (is_larger? a->rb + pes[r].low : a->rb - pes[r].high) - l_ms; // similarly on opposite strands
bwamem_pair.cpp:            re = is_larger? a->rb + pes[r].high: a->rb - pes[r].low;
bwamem_pair.cpp:        if (a->rid == rid && re - rb >= opt->min_seed_len) { // no funny things happening
bwamem_pair.cpp:            int xtra = KSW_XSUBO | KSW_XSTART | (l_ms * opt->a < 250? KSW_XBYTE : 0) | (opt->min_seed_len * opt->a);
bwamem_pair.cpp:                sp = seqPairArray[pcnt - 1];
bwamem_pair.cpp:            sp.len1 = re - rb;
bwamem_pair.cpp:            sp.id = sp.score = sp.seqid = sp.gtle = sp.tle = sp.qle = sp.max_off = sp.gscore = -1; // not needed, remove while code cleaning
bwamem_pair.cpp:                fprintf(stderr, "[0000][%0.4d] Re-allocating (doubling) seqBufRefs in %s\n",
bwamem_pair.cpp:                mmc->seqBufLeftRef[tid*CACHE_LINE] = seqBufRef = seqBufRef_;
bwamem_pair.cpp:                    _mm_realloc(mmc->seqBufRightRef[tid*CACHE_LINE], tmp,
bwamem_pair.cpp:                mmc->seqBufRightRef[tid*CACHE_LINE] = seqBufRef_;               
bwamem_pair.cpp:                fprintf(stderr, "[0000][%0.4d] Re-allocating (doubling) seqBufQers in %s\n",
bwamem_pair.cpp:                mmc->seqBufLeftQer[tid*CACHE_LINE] = seqBufQer = seqBufQer_;
bwamem_pair.cpp:                    _mm_realloc(mmc->seqBufRightQer[tid*CACHE_LINE], tmp,
bwamem_pair.cpp:                mmc->seqBufRightQer[tid*CACHE_LINE] = seqBufQer_;               
bwamem_pair.cpp:                fprintf(stderr, "[0000][%0.4d] Re-allocating seqPairs in %s\n", tid, __func__);
bwamem_pair.cpp:                mmc->seqPairArrayAux[tid] = (SeqPair *) realloc(mmc->seqPairArrayAux[tid],
bwamem_pair.cpp:                mmc->seqPairArrayLeft128[tid] = (SeqPair *) realloc(mmc->seqPairArrayLeft128[tid],
bwamem_pair.cpp:                mmc->seqPairArrayRight128[tid] = (SeqPair *) realloc(mmc->seqPairArrayRight128[tid],
bwamem_pair.cpp:                seqPairArray = mmc->seqPairArrayLeft128[tid];
bwamem_pair.cpp:                gar = (int32_t*) (mmc->seqPairArrayAux[tid]);               
bwamem_pair.cpp:    int64_t l_pac = bns->l_pac;
bwamem_pair.cpp:    int i, r, skip[4], n = 0, rid = -1;
bwamem_pair.cpp:    for (i = 0; i < ma->n; ++i) { // check which orinentation has been found
bwamem_pair.cpp:        r = mem_infer_dir(l_pac, a->rb, ma->a[i].rb, &dist);
bwamem_pair.cpp:            for (i = 0; i < l_ms; ++i) rev[l_ms - 1 - i] = ms[i] < 4? 3 - ms[i] : 4;
bwamem_pair.cpp:            rb = is_larger? a->rb + pes[r].low : a->rb - pes[r].high;
bwamem_pair.cpp:            re = (is_larger? a->rb + pes[r].high: a->rb - pes[r].low) + l_ms; // if on the same strand, end position should be larger to make room for the seq length
bwamem_pair.cpp:            rb = (is_larger? a->rb + pes[r].low : a->rb - pes[r].high) - l_ms; // similarly on opposite strands
bwamem_pair.cpp:            re = is_larger? a->rb + pes[r].high: a->rb - pes[r].low;
bwamem_pair.cpp:        if (a->rid == rid && re - rb >= opt->min_seed_len) { // no funny things happening
bwamem_pair.cpp:            int tmp, xtra = KSW_XSUBO | KSW_XSTART | (l_ms * opt->a < 250? KSW_XBYTE : 0) | (opt->min_seed_len * opt->a);
bwamem_pair.cpp:            if (index == -1) {
bwamem_pair.cpp:                // fprintf(stderr, "Re-routing: Encountered -ve index for "
bwamem_pair.cpp:                aln = ksw_align2(l_ms, seq, re - rb, ref, 5,
bwamem_pair.cpp:                                 opt->mat, opt->o_del, opt->e_del,
bwamem_pair.cpp:                                 opt->o_ins, opt->e_ins, xtra, 0);
bwamem_pair.cpp:            if (aln.score >= opt->min_seed_len && aln.qb >= 0) { // something goes wrong if aln.qb < 0
bwamem_pair.cpp:                b.rid = a->rid;
bwamem_pair.cpp:                b.is_alt = a->is_alt;
bwamem_pair.cpp:                b.qb = is_rev? l_ms - (aln.qe + 1) : aln.qb;
bwamem_pair.cpp:                b.qe = is_rev? l_ms - aln.qb : aln.qe + 1; 
bwamem_pair.cpp:                b.rb = is_rev? (l_pac<<1) - (rb + aln.te + 1) : rb + aln.tb;
bwamem_pair.cpp:                b.re = is_rev? (l_pac<<1) - (rb + aln.tb) : rb + aln.te + 1;
bwamem_pair.cpp:                b.secondary = -1;
bwamem_pair.cpp:                b.seedcov = (b.re - b.rb < b.qe - b.qb? b.re - b.rb : b.qe - b.qb) >> 1;
bwamem_pair.cpp:                for (i = 0; i < ma->n - 1; ++i) // find the insertion point
bwamem_pair.cpp:                    if (ma->a[i].score < b.score) break;
bwamem_pair.cpp:                for (i = ma->n - 1; i > tmp; --i) ma->a[i] = ma->a[i-1];
bwamem_pair.cpp:                ma->a[i] = b;
bwamem_pair.cpp:        if (n) ma->n = mem_sort_dedup_patch(opt, 0, 0, 0, ma->n, ma->a);        
memcpy_bwamem.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
kstring.h:#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
kstring.h:	if (s->m < size) {
kstring.h:		s->m = size;
kstring.h:		kroundup32(s->m);
kstring.h:		s->s = (char*)realloc(s->s, s->m);
kstring.h:	if (s->l + l + 1 >= s->m) {
kstring.h:		s->m = s->l + l + 2;
kstring.h:		kroundup32(s->m);
kstring.h:		s->s = (char*)realloc(s->s, s->m);
kstring.h:	memcpy_bwamem(s->s + s->l, s->m - s->l, p, l, __FILE__, __LINE__);
kstring.h:	s->l += l;
kstring.h:	s->s[s->l] = 0;
kstring.h:	if (s->l + 1 >= s->m) {
kstring.h:		s->m = s->l + 2;
kstring.h:		kroundup32(s->m);
kstring.h:		s->s = (char*)realloc(s->s, s->m);
kstring.h:	s->s[s->l++] = c;
kstring.h:	s->s[s->l] = 0;
kstring.h:	for (l = 0, x = c < 0? -c : c; x > 0; x /= 10) buf[l++] = x%10 + '0';
kstring.h:	if (c < 0) buf[l++] = '-';
kstring.h:	if (s->l + l + 1 >= s->m) {
kstring.h:		s->m = s->l + l + 2;
kstring.h:		kroundup32(s->m);
kstring.h:		s->s = (char*)realloc(s->s, s->m);
kstring.h:	for (x = l - 1; x >= 0; --x) s->s[s->l++] = buf[x];
kstring.h:	s->s[s->l] = 0;
kstring.h:	if (s->l + l + 1 >= s->m) {
kstring.h:		s->m = s->l + l + 2;
kstring.h:		kroundup32(s->m);
kstring.h:		s->s = (char*)realloc(s->s, s->m);
kstring.h:	for (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];
kstring.h:	s->s[s->l] = 0;
kstring.h:	for (l = 0, x = c < 0? -c : c; x > 0; x /= 10) buf[l++] = x%10 + '0';
kstring.h:	if (c < 0) buf[l++] = '-';
kstring.h:	if (s->l + l + 1 >= s->m) {
kstring.h:		s->m = s->l + l + 2;
kstring.h:		kroundup32(s->m);
kstring.h:		s->s = (char*)realloc(s->s, s->m);
kstring.h:	for (x = l - 1; x >= 0; --x) s->s[s->l++] = buf[x];
kstring.h:	s->s[s->l] = 0;
FMI_search.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
FMI_search.h:        map<pair<int,int>,pair<pair<int,int>,pair<int,int> > > cp_occ_cp_count_map;        // For cp_occ[i].cp_count[j]-  ((i,j),((ciphertext_1_no,index_in_ciphertext_1),(ciphertext_2_no,index_in_ciphertext_2)))
runsimd.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
runsimd.cpp:// adapted from https://github.com/01org/linux-sgx/blob/master/common/inc/internal/linux/cpuid_gnu.h
runsimd.cpp:	if (exe == 0 || max == 0) return -1;
runsimd.cpp:	for (i = len - 1; i >= 0; --i)
runsimd.cpp:		if (max < last_slash + 2) return -1;
runsimd.cpp:		if (p == 0) return -1;
runsimd.cpp:		//if (max < abs_len + 3 + last_slash) return -1;
runsimd.cpp:		//strncpy_s(buf + abs_len + 1, max - (abs_len + 1), exe, last_slash + 1);
runsimd.cpp:				strncpy_s(tmp, env_len + len + 2, q, p - q);
runsimd.cpp:				tmp[p - q] = '/';
runsimd.cpp:				strcpy_s(tmp + (p - q + 1), env_len + len + 2 - (p - q + 1), exe);
runsimd.cpp:			return -2; // shouldn't happen!
Binary file main.o matches
ksw.h:const kswr_t g_defr = { 0, -1, -1, -1, -1, -1, -1 };
ksw.h:	 * @param mat     m*m scoring matrix in one-dimension array
ksw.h:	 * @param gapo    gap open penalty; a gap of length l cost "-(gapo+l*gape)"
ksw.h:	 * @return        alignment information in a struct; unset values to -1
ksw.h:	 * When xtra==0, ksw_align() uses a signed two-byte integer to store a
ksw.h:	 * @param mat     m*m scoring mattrix in one-dimension array
ksw.h:	 * @param gapo    gap open penalty; a gap of length l cost "-(gapo+l*gape)"
ksw.h:	 * @param cigar   (out) BAM-encoded CIGAR; caller need to deallocate with free()
ksw.h:	 * caller to decide whether an end-to-end hit or a partial hit is preferred.
ksw.h:	 * @param _gscore (out) score of the best end-to-end alignment; negative if not found
ksw.h:	 * @return        best semi-local alignment score
kthread.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
kthread.cpp:	int i, min_i = -1;
kthread.cpp:	for (i = 0; i < t->n_threads; ++i)
kthread.cpp:		if (min > t->w[i].i) min = t->w[i].i, min_i = i;
kthread.cpp:	k = __sync_fetch_and_add(&t->w[min_i].i, t->n_threads);
kthread.cpp:	// return k >= t->n? -1 : k;
kthread.cpp:	return k*BATCH_SIZE >= t->n? -1 : k;
kthread.cpp:	int tid = w->i;
kthread.cpp:		i = __sync_fetch_and_add(&w->i, w->t->n_threads);
kthread.cpp:		if (st >= w->t->n) break;
kthread.cpp:		int ed = (i + 1) * BATCH_SIZE < w->t->n? (i + 1) * BATCH_SIZE : w->t->n;
kthread.cpp:		w->t->func(w->t->data, st, ed-st, tid);
kthread.cpp:	while ((i = steal_work(w->t)) >= 0) {
kthread.cpp:		int ed = (i + 1) * BATCH_SIZE < w->t->n? (i + 1) * BATCH_SIZE : w->t->n;
kthread.cpp:		w->t->func(w->t->data, st, ed-st, tid);
kthread.cpp:	t.func = func, t.data = data, t.n_threads = w->nthreads, t.n = n;
kswv.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
kswv.h:#define DEFAULT_AMBIG -1
kswv.h:const kswr_t g_defr = { 0, -1, -1, -1, -1, -1, -1 };
kswv.h:						int xtra);  // the first gap costs -(_o+_e)
kswv.h:						  int xtra); // the first gap costs -(_o+_e)
bandedSWA.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bandedSWA.h:// used in BSW and SAM-SW
bandedSWA.h:#define DEFAULT_AMBIG -1
bandedSWA.h:#define LOW_INIT_VALUE -128
fastmap.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
Binary file bwa.o matches
khash.h:  2011-12-29 (0.2.7):
khash.h:  2011-09-16 (0.2.6):
khash.h:	   - http://code.google.com/p/ulib/
khash.h:	   - http://nothings.org/computer/judy/
khash.h:	  is more robust to certain non-random input.
khash.h:	  function is more robust to certain non-random input.
khash.h:  2011-02-14 (0.2.5):
khash.h:  2009-09-26 (0.2.4):
khash.h:  2008-09-19 (0.2.3):
khash.h:  2008-09-11 (0.2.2):
khash.h:  2008-09-10 (0.2.1):
khash.h:  2008-09-02 (0.2.0):
khash.h:  2008-08-31 (0.1.2):
khash.h:  2008-08-31 (0.1.1):
khash.h:#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
khash.h:			kfree((void *)h->keys); kfree(h->flags);					\
khash.h:			kfree((void *)h->vals);										\
khash.h:		if (h && h->flags) {											\
khash.h:			memset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \
khash.h:			h->size = h->n_occupied = 0;								\
khash.h:		if (h->n_buckets) {												\
khash.h:			mask = h->n_buckets - 1;									\
khash.h:			while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
khash.h:				if (i == last) return h->n_buckets;						\
khash.h:			return __ac_iseither(h->flags, i)? h->n_buckets : i;		\
khash.h:			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	/* requested size is too small */ \
khash.h:				if (!new_flags) return -1;								\
khash.h:				if (h->n_buckets < new_n_buckets) {	/* expand */		\
khash.h:					khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
khash.h:					if (!new_keys) return -1;							\
khash.h:					h->keys = new_keys;									\
khash.h:						khval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
khash.h:						if (!new_vals) return -1;						\
khash.h:						h->vals = new_vals;								\
khash.h:			for (j = 0; j != h->n_buckets; ++j) {						\
khash.h:				if (__ac_iseither(h->flags, j) == 0) {					\
khash.h:					khkey_t key = h->keys[j];							\
khash.h:					new_mask = new_n_buckets - 1; 						\
khash.h:					if (kh_is_map) val = h->vals[j];					\
khash.h:					__ac_set_isdel_true(h->flags, j);					\
khash.h:					while (1) { /* kick-out process; sort of like in Cuckoo hashing */ \
khash.h:						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \
khash.h:							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
khash.h:							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
khash.h:							__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \
khash.h:							h->keys[i] = key;							\
khash.h:							if (kh_is_map) h->vals[i] = val;			\
khash.h:			if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \
khash.h:				h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
khash.h:				if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
khash.h:			kfree(h->flags); /* free the working space */				\
khash.h:			h->flags = new_flags;										\
khash.h:			h->n_buckets = new_n_buckets;								\
khash.h:			h->n_occupied = h->size;									\
khash.h:			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
khash.h:		if (h->n_occupied >= h->upper_bound) { /* update the hash table */ \
khash.h:			if (h->n_buckets > (h->size<<1)) {							\
khash.h:				if (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear "deleted" elements */ \
khash.h:					*ret = -1; return h->n_buckets;						\
khash.h:			} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
khash.h:				*ret = -1; return h->n_buckets;							\
khash.h:			khint_t inc, k, i, site, last, mask = h->n_buckets - 1;		\
khash.h:			x = site = h->n_buckets; k = __hash_func(key); i = k & mask; \
khash.h:			if (__ac_isempty(h->flags, i)) x = i; /* for speed up */	\
khash.h:				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
khash.h:					if (__ac_isdel(h->flags, i)) site = i;				\
khash.h:				if (x == h->n_buckets) {								\
khash.h:					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
khash.h:		if (__ac_isempty(h->flags, x)) { /* not present at all */		\
khash.h:			h->keys[x] = key;											\
khash.h:			__ac_set_isboth_false(h->flags, x);							\
khash.h:			++h->size; ++h->n_occupied;									\
khash.h:		} else if (__ac_isdel(h->flags, x)) { /* deleted */				\
khash.h:			h->keys[x] = key;											\
khash.h:			__ac_set_isboth_false(h->flags, x);							\
khash.h:			++h->size;													\
khash.h:		} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \
khash.h:		if (x != h->n_buckets && !__ac_iseither(h->flags, x)) {			\
khash.h:			__ac_set_isdel_true(h->flags, x);							\
khash.h:			--h->size;													\
khash.h:/* --- BEGIN OF HASH FUNCTIONS --- */
khash.h:  @abstract     64-bit integer hash function
khash.h:  @abstract     64-bit integer comparison function
khash.h:	if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
khash.h:/* --- END OF HASH FUNCTIONS --- */
khash.h:#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))
khash.h:#define kh_key(h, x) ((h)->keys[x])
khash.h:#define kh_val(h, x) ((h)->vals[x])
khash.h:#define kh_value(h, x) ((h)->vals[x])
khash.h:#define kh_end(h) ((h)->n_buckets)
khash.h:#define kh_size(h) ((h)->size)
khash.h:#define kh_n_buckets(h) ((h)->n_buckets)
khash.h:  @abstract     Instantiate a hash map containing 64-bit integer keys
khash.h:  @abstract     Instantiate a hash map containing 64-bit integer keys
Binary file utils.o matches
bwamem.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwamem.cpp://----------------
bwamem.cpp://----------------
bwamem.cpp:#define chain_cmp(a, b) (((b).pos < (a).pos) - ((a).pos < (b).pos))
bwamem.cpp:#define chn_beg(ch) ((ch).seeds->qbeg)
bwamem.cpp:#define chn_end(ch) ((ch).seeds[(ch).n-1].qbeg + (ch).seeds[(ch).n-1].len)
bwamem.cpp://------------------------------------------------------------------
bwamem.cpp:    int l_del = (int)((double)(qlen * opt->a - opt->o_del) / opt->e_del + 1.);
bwamem.cpp:    int l_ins = (int)((double)(qlen * opt->a - opt->o_ins) / opt->e_ins + 1.);
bwamem.cpp:    //int l_del = (int)((double)(qlen * opt->a - opt->o_del) + 1.);
bwamem.cpp:    //int l_ins = (int)((double)(qlen * opt->a - opt->o_ins) + 1.);
bwamem.cpp:    return l < opt->w<<1? l : opt->w<<1;
bwamem.cpp://------------------------------------------------------------------
bwamem.cpp:        free(a[i].tmpv[0]->a);
bwamem.cpp:        free(a[i].tmpv[1]->a);
bwamem.cpp:    o->flag = 0;
bwamem.cpp:    o->a = 1; o->b = 4;
bwamem.cpp:    o->o_del = o->o_ins = 6;
bwamem.cpp:    o->e_del = o->e_ins = 1;
bwamem.cpp:    o->w = 100;
bwamem.cpp:    o->T = 30;
bwamem.cpp:    o->zdrop = 100;
bwamem.cpp:    o->pen_unpaired = 17;
bwamem.cpp:    o->pen_clip5 = o->pen_clip3 = 5;
bwamem.cpp:    o->max_mem_intv = 20;
bwamem.cpp:    o->min_seed_len = 19;
bwamem.cpp:    o->split_width = 10;
bwamem.cpp:    o->max_occ = 500;
bwamem.cpp:    o->max_chain_gap = 10000;
bwamem.cpp:    o->max_ins = 10000;
bwamem.cpp:    o->mask_level = 0.50;
bwamem.cpp:    o->drop_ratio = 0.50;
bwamem.cpp:    o->XA_drop_ratio = 0.80;
bwamem.cpp:    o->split_factor = 1.5;
bwamem.cpp:    o->chunk_size = 10000000;
bwamem.cpp:    o->n_threads = 1;
bwamem.cpp:    o->max_XA_hits = 5;
bwamem.cpp:    o->max_XA_hits_alt = 200;
bwamem.cpp:    o->max_matesw = 50;
bwamem.cpp:    o->mask_level_redun = 0.95;
bwamem.cpp:    o->min_chain_weight = 0;
bwamem.cpp:    o->max_chain_extend = 1<<30;
bwamem.cpp:    o->mapQ_coef_len = 50; o->mapQ_coef_fac = log(o->mapQ_coef_len);
bwamem.cpp:    bwa_fill_scmat(o->a, o->b, o->mat);
bwamem.cpp: * De-overlap single-end hits *
bwamem.cpp:    assert(a->rid == b->rid && a->rb <= b->rb);
bwamem.cpp:    if (a->rb < bns->l_pac && b->rb >= bns->l_pac) return 0; // on different strands
bwamem.cpp:    if (a->qb >= b->qb || a->qe >= b->qe || a->re >= b->re) return 0; // not colinear
bwamem.cpp:    w = (a->re - b->rb) - (a->qe - b->qb); // required bandwidth
bwamem.cpp:    w = w > 0? w : -w; // l = abs(l)
bwamem.cpp:    r = (double)(a->re - b->rb) / (b->re - a->rb) - (double)(a->qe - b->qb) / (b->qe - a->qb); // relative bandwidth
bwamem.cpp:    r = r > 0.? r : -r; // r = fabs(r)
bwamem.cpp:               a->qb, a->qe, (long)a->rb, (long)a->re, b->qb, b->qe,
bwamem.cpp:               (long)b->rb, (long)b->re, bns->anns[a->rid].name, w, r);
bwamem.cpp:    if (a->re < b->rb || a->qe < b->qb) // no overlap on query or on ref
bwamem.cpp:        if (w > opt->w<<1 || r >= PATCH_MAX_R_BW) return 0; // the bandwidth or the relative bandwidth is too large
bwamem.cpp:    } else if (w > opt->w<<2 || r >= PATCH_MAX_R_BW*2) return 0; // more permissive if overlapping on both ref and query
bwamem.cpp:    w += a->w + b->w;
bwamem.cpp:    w = w < opt->w<<2? w : opt->w<<2;
bwamem.cpp:    bwa_gen_cigar2(opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, w,
bwamem.cpp:                   bns->l_pac, pac, b->qe - a->qb, query + a->qb, a->rb, b->re,
bwamem.cpp:    q_s = (int)((double)(b->qe - a->qb) / ((b->qe - b->qb) + (a->qe - a->qb)) *
bwamem.cpp:                (b->score + a->score) + .499); // predicted score from query
bwamem.cpp:    r_s = (int)((double)(b->re - a->rb) / ((b->re - b->rb) + (a->re - a->rb)) *
bwamem.cpp:                (b->score + a->score) + .499); // predicted score from ref
bwamem.cpp:        if (p->rid != a[i-1].rid || p->rb >= a[i-1].re + opt->max_chain_gap)
bwamem.cpp:        for (j = i - 1; j >= 0 && p->rid == a[j].rid && p->rb < a[j].re + opt->max_chain_gap; --j) {
bwamem.cpp:            if (q->qe == q->qb) continue; // a[j] has been excluded
bwamem.cpp:            or_ = q->re - p->rb; // overlap length on the reference
bwamem.cpp:            oq = q->qb < p->qb? q->qe - p->qb : p->qe - q->qb; // overlap length on the query
bwamem.cpp:            mr = q->re - q->rb < p->re - p->rb? q->re - q->rb : p->re - p->rb; // min ref len in alignment
bwamem.cpp:            mq = q->qe - q->qb < p->qe - p->qb? q->qe - q->qb : p->qe - p->qb; // min qry len in alignment
bwamem.cpp:            if (or_ > opt->mask_level_redun * mr && oq > opt->mask_level_redun * mq) { // one of the hits is redundant
bwamem.cpp:                if (p->score < q->score)
bwamem.cpp:                    p->qe = p->qb;
bwamem.cpp:                else q->qe = q->qb;
bwamem.cpp:            else if (q->rb < p->rb && (score = mem_patch_reg(opt, bns, pac, query, q, p, &w)) > 0) { // then merge q into p
bwamem.cpp:                p->n_comp += q->n_comp + 1;
bwamem.cpp:                p->seedcov = p->seedcov > q->seedcov? p->seedcov : q->seedcov;
bwamem.cpp:                p->sub = p->sub > q->sub? p->sub : q->sub;
bwamem.cpp:                p->csub = p->csub > q->csub? p->csub : q->csub;
bwamem.cpp:                p->qb = q->qb, p->rb = q->rb;
bwamem.cpp:                p->truesc = p->score = score;
bwamem.cpp:                p->w = w;
bwamem.cpp:                q->qb = q->qe;
bwamem.cpp:        if (a[i].score == a[i-1].score && a[i].rb == a[i-1].rb && a[i].qb == a[i-1].qb)
bwamem.cpp:    const mem_seed_t *last = &c->seeds[c->n-1];
bwamem.cpp:    qend = last->qbeg + last->len;
bwamem.cpp:    rend = last->rbeg + last->len;
bwamem.cpp:    if (seed_rid != c->rid) return 0; // different chr; request a new chain
bwamem.cpp:    if (p->qbeg >= c->seeds[0].qbeg && p->qbeg + p->len <= qend &&
bwamem.cpp:        p->rbeg >= c->seeds[0].rbeg && p->rbeg + p->len <= rend)
bwamem.cpp:    if ((last->rbeg < l_pac || c->seeds[0].rbeg < l_pac) &&
bwamem.cpp:        p->rbeg >= l_pac) return 0; // don't chain if on different strand
bwamem.cpp:    x = p->qbeg - last->qbeg; // always non-negtive
bwamem.cpp:    y = p->rbeg - last->rbeg;
bwamem.cpp:    if (y >= 0 && x - y <= opt->w && y - x <= opt->w &&
bwamem.cpp:        x - last->len < opt->max_chain_gap &&
bwamem.cpp:        y - last->len < opt->max_chain_gap) { // grow the chain
bwamem.cpp:        if (c->n == c->m)
bwamem.cpp:            int pm = c->m;          
bwamem.cpp:            c->m <<= 1;
bwamem.cpp:            if (pm == SEEDS_PER_CHAIN) {  // re-new memory
bwamem.cpp:                if ((auxSeedBuf = (mem_seed_t *) calloc(c->m, sizeof(mem_seed_t))) == NULL) { fprintf(stderr, "ERROR: out of memory auxSeedBuf\n"); exit(1); }
bwamem.cpp:                memcpy_bwamem((char*) (auxSeedBuf), c->m * sizeof(mem_seed_t), c->seeds, c->n * sizeof(mem_seed_t), __FILE__, __LINE__);
bwamem.cpp:                c->seeds = auxSeedBuf;
bwamem.cpp:                // fprintf(stderr, "[%0.4d] re-allocing old seed, m: %d\n", tid, c->m);
bwamem.cpp:                if ((auxSeedBuf = (mem_seed_t *) realloc(c->seeds, c->m * sizeof(mem_seed_t))) == NULL) { fprintf(stderr, "ERROR: out of memory auxSeedBuf\n"); exit(1); }
bwamem.cpp:                c->seeds = auxSeedBuf;
bwamem.cpp:            memset((char*) (c->seeds + c->n), 0, (c->m - c->n) * sizeof(mem_seed_t));           
bwamem.cpp:        c->seeds[c->n++] = *p;
bwamem.cpp:    int64_t rb, re, mid, l_pac = bns->l_pac;
bwamem.cpp:    if (s->len >= MEM_SHORT_LEN) return -1; // the seed is longer than the max-extend; no need to do SW
bwamem.cpp:    qb = s->qbeg, qe = s->qbeg + s->len;
bwamem.cpp:    rb = s->rbeg, re = s->rbeg + s->len;
bwamem.cpp:    qb -= MEM_SHORT_EXT; qb = qb > 0? qb : 0;
bwamem.cpp:    rb -= MEM_SHORT_EXT; rb = rb > 0? rb : 0;
bwamem.cpp:    if (qe - qb >= MEM_SHORT_LEN || re - rb >= MEM_SHORT_LEN) return -1; // the seed seems good enough; no need to do SW
bwamem.cpp:    x = ksw_align2(qe - qb, (uint8_t*)query + qb, re - rb, rseq, 5, opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, KSW_XSTART, 0);
bwamem.cpp:    for (j = 0, end = 0; j < c->n; ++j) {
bwamem.cpp:        const mem_seed_t *s = &c->seeds[j];
bwamem.cpp:        if (s->qbeg >= end) w += s->len;
bwamem.cpp:        else if (s->qbeg + s->len > end) w += s->qbeg + s->len - end;
bwamem.cpp:        end = end > s->qbeg + s->len? end : s->qbeg + s->len;
bwamem.cpp:    for (j = 0, end = 0; j < c->n; ++j) {
bwamem.cpp:        const mem_seed_t *s = &c->seeds[j];
bwamem.cpp:        if (s->rbeg >= end) w += s->len;
bwamem.cpp:        else if (s->rbeg + s->len > end) w += s->rbeg + s->len - end;
bwamem.cpp:        end = end > s->rbeg + s->len? end : s->rbeg + s->len;
bwamem.cpp:    return w < 1<<30? w : (1<<30)-1;
bwamem.cpp:    for (i = 0; i < chn->n; ++i)
bwamem.cpp:        mem_chain_t *p = &chn->a[i];
bwamem.cpp:        fprintf(stderr, "* Found CHAIN(%d): n=%d; weight=%d", i, p->n, mem_chain_weight(p));
bwamem.cpp:        for (j = 0; j < p->n; ++j)
bwamem.cpp:            pos = bns_depos(bns, p->seeds[j].rbeg, &is_rev);
bwamem.cpp:            if (is_rev) pos -= p->seeds[j].len - 1;
bwamem.cpp:                       p->seeds[j].score, p->seeds[j].len, p->seeds[j].qbeg,
bwamem.cpp:                       (long)p->seeds[j].rbeg, bns->anns[p->rid].name,
bwamem.cpp:                       "+-"[is_rev], (long)(pos - bns->anns[p->rid].offset) + 1);
bwamem.cpp:    //double min_l = opt->min_chain_weight?
bwamem.cpp:    // MEM_HSP_COEF * opt->min_chain_weight : MEM_MINSC_COEF * log(l_query);
bwamem.cpp:    int i, j, k;// min_HSP_score = (int)(opt->a * min_l + .499);
bwamem.cpp:        const uint8_t *query = (uint8_t*) seq_[c->seqid].seq;
bwamem.cpp:        int l_query = seq_[c->seqid].l_seq;
bwamem.cpp:        double min_l = opt->min_chain_weight?
bwamem.cpp:        MEM_HSP_COEF * opt->min_chain_weight : MEM_MINSC_COEF * log(l_query);
bwamem.cpp:        int min_HSP_score = (int)(opt->a * min_l + .499);
bwamem.cpp:        for (j = k = 0; j < c->n; ++j)
bwamem.cpp:            mem_seed_t *s = &c->seeds[j];
bwamem.cpp:            s->score = mem_seed_sw(opt, bns, pac, l_query, query, s);
bwamem.cpp:            if (s->score < 0 || s->score >= min_HSP_score)
bwamem.cpp:                s->score = s->score < 0? s->len * opt->a : s->score;
bwamem.cpp:                c->seeds[k++] = *s;
bwamem.cpp:        c->n = k;
bwamem.cpp:        c->first = -1; c->kept = 0;
bwamem.cpp:        c->w = mem_chain_weight(c);
bwamem.cpp:        if (c->w < opt->min_chain_weight)
bwamem.cpp:            if (c->m > SEEDS_PER_CHAIN) {
bwamem.cpp:                free(c->seeds);
bwamem.cpp:            //free(c->seeds);
bwamem.cpp:        if (c->seqid != pseqid) {
bwamem.cpp:            //if (flag == -1) {
bwamem.cpp:                // flag = -1;
bwamem.cpp:        pseqid = c->seqid;
bwamem.cpp:        // this keeps int indices of the non-overlapping chains
bwamem.cpp:        int n_chn = range[l].second - range[l].first;
bwamem.cpp:                    int li = chn_end(a[i]) - chn_beg(a[i]);
bwamem.cpp:                    int lj = chn_end(a[j]) - chn_beg(a[j]);
bwamem.cpp:                    if (e_min - b_max >= min_l * opt->mask_level && min_l < opt->max_chain_gap) { // significant overlap
bwamem.cpp:                        if (a[i].w < a[j].w * opt->drop_ratio && a[j].w - a[i].w >= opt->min_seed_len<<1)
bwamem.cpp:            if (c->first >= 0) a[c->first].kept = 1;
bwamem.cpp:        for (i = k = 0; i < n_chn; ++i) { // don't extend more than opt->max_chain_extend .kept=1/2 chains
bwamem.cpp:            if (++k >= opt->max_chain_extend) break;
bwamem.cpp:            if (c->kept == 0)
bwamem.cpp:                if (c->m > SEEDS_PER_CHAIN) {
bwamem.cpp:                    free(c->seeds);
bwamem.cpp:                //free(c->seeds);
bwamem.cpp:            else a[k++ - ilag] = a[i];
bwamem.cpp:        ilag += n_chn - k;
bwamem.cpp:    int split_len = (int)(opt->min_seed_len * opt->split_factor + .499);
bwamem.cpp:    int max_readlength = -1;
bwamem.cpp:        query_cum_len_ar[i] = query_cum_len_ar[i - 1] + seq_[i-1].l_seq;
bwamem.cpp:    fmi->getSMEMsAllPosOneThread(enc_qdb, min_intv_ar, rid, nseq, nseq,
bwamem.cpp:                                 seq_, query_cum_len_ar, max_readlength, opt->min_seed_len,
bwamem.cpp:        int start = p->m, end = p->n +1;
bwamem.cpp:        if (end - start < split_len || p->s > opt->split_width)
bwamem.cpp:        int len = seq_[p->rid].l_seq;
bwamem.cpp:        rid[pos] = p->rid;
bwamem.cpp:        min_intv_ar[pos] = p->s + 1;
bwamem.cpp:    fmi->getSMEMsOnePosOneThread(enc_qdb,
bwamem.cpp:                                 opt->min_seed_len,
bwamem.cpp:    if (opt->max_mem_intv > 0)
bwamem.cpp:            min_intv_ar[l] = opt->max_mem_intv;
bwamem.cpp:        num_smem3 = fmi->bwtSeedStrategyAllPosOneThread(enc_qdb, min_intv_ar,
bwamem.cpp:                                                        opt->min_seed_len + 1,
bwamem.cpp:    fmi->sortSMEMs(matchArray, &tot_smem, nseq, seq_[0].l_seq, 1); // seq_[0].l_seq - only used for blocking when using nthreads
bwamem.cpp:    for (int l=0; l<nseq && pos < tot_smem - 1; l++) {
bwamem.cpp:        pos = smem_ptr - 1;
bwamem.cpp:        } while (pos < tot_smem - 1 && matchArray[pos].rid == matchArray[pos + 1].rid);
bwamem.cpp:        int64_t n = pos + 1 - smem_ptr;
bwamem.cpp:    int64_t l_pac = bns->l_pac;
bwamem.cpp:    int64_t *sa_coord = (int64_t *) _mm_malloc(sizeof(int64_t) * opt->max_occ * smem_buf_size, 64);
bwamem.cpp:    // if (len < opt->min_seed_len) return chain; // if the query is shorter than the seed length, no match
bwamem.cpp:    for (int l=0; l<nseq && pos < num_smem - 1; l++)
bwamem.cpp:        //if (aux_->mem.n == 0) continue;
bwamem.cpp:        if (seq_[l].l_seq < opt->min_seed_len) continue;
bwamem.cpp:        pos = smem_ptr - 1;
bwamem.cpp:        //for (i = 0, b = e = l_rep = 0; i < aux_->mem.n; ++i) // compute frac_rep
bwamem.cpp:            int sb = p->m, se = p->n + 1;
bwamem.cpp:            if (p->s <= opt->max_occ) continue;
bwamem.cpp:            if (sb > e) l_rep += e - b, b = sb, e = se;
bwamem.cpp:        } while (pos < num_smem - 1 && matchArray[pos].rid == matchArray[pos + 1].rid);
bwamem.cpp:        l_rep += e - b;
bwamem.cpp:        // assert(pos - smem_ptr + 1 < 6000);
bwamem.cpp:        if (pos - smem_ptr + 1 >= smem_buf_size)
bwamem.cpp:            sa_coord = (int64_t *) _mm_realloc(sa_coord, csize, opt->max_occ * smem_buf_size,
bwamem.cpp:        fmi->get_sa_entries_prefetch(&matchArray[smem_ptr], sa_coord, &cnt_,
bwamem.cpp:                                     pos - smem_ptr + 1, opt->max_occ, tid, id);  // sa compressed prefetch
bwamem.cpp:        tprof[MEM_SA][tid] += __rdtsc() - tim;
bwamem.cpp:            int32_t count, slen = p->n + 1 - p->m; // seed length
bwamem.cpp:            step = p->s > opt->max_occ? p->s / opt->max_occ : 1;
bwamem.cpp:            fmi->get_sa_entries(p, sa_coord, &cnt, 1, opt->max_occ);
bwamem.cpp:            tprof[MEM_SA][tid] += __rdtsc() - tim;
bwamem.cpp:            for (k = count = 0; k < p->s && count < opt->max_occ; k += step, ++count)
bwamem.cpp:                s.qbeg = p->m;
bwamem.cpp:                            s.rbeg, s.len, cnt-1, p->n, p->m, num_smem);
bwamem.cpp:                // forward-reverse boundary; TODO: split the seed;
bwamem.cpp:                    tmp.is_alt = !!bns->anns[rid].is_alt;
bwamem.cpp:#define traverse_func(p_) (chain->a[chain->n++] = *(p_))
bwamem.cpp:        for (i = 0; i < chain->n; ++i)
bwamem.cpp:            chain->a[i].frac_rep = (float)l_rep / seq_[l].l_seq;
bwamem.cpp:    tprof[MEM_SA_BLOCK][tid] += __rdtsc() - tim;
bwamem.cpp:    /* convert to 2-bit encoding if we have not done so */
bwamem.cpp:    if (tot_len >= mmc->wsize_mem[tid])
bwamem.cpp:        fprintf(stderr, "[%0.4d] Re-allocating SMEM data structures due to enc_qdb\n", tid);
bwamem.cpp:        int64_t tmp = mmc->wsize_mem[tid];
bwamem.cpp:        mmc->wsize_mem[tid] *= 2;
bwamem.cpp:        mmc->matchArray[tid]   = (SMEM *) _mm_realloc(mmc->matchArray[tid],
bwamem.cpp:                                                      tmp, mmc->wsize_mem[tid], sizeof(SMEM));
bwamem.cpp:            //realloc(mmc->matchArray[tid], mmc->wsize_mem[tid] *   sizeof(SMEM));
bwamem.cpp:        mmc->min_intv_ar[tid]  = (int32_t *) realloc(mmc->min_intv_ar[tid],
bwamem.cpp:                                                     mmc->wsize_mem[tid] *  sizeof(int32_t));
bwamem.cpp:        mmc->query_pos_ar[tid] = (int16_t *) realloc(mmc->query_pos_ar[tid],
bwamem.cpp:                                                     mmc->wsize_mem[tid] *  sizeof(int16_t));
bwamem.cpp:        mmc->enc_qdb[tid]      = (uint8_t *) realloc(mmc->enc_qdb[tid],
bwamem.cpp:                                                      mmc->wsize_mem[tid] * sizeof(uint8_t));
bwamem.cpp:        mmc->rid[tid]          = (int32_t *) realloc(mmc->rid[tid],
bwamem.cpp:                                                      mmc->wsize_mem[tid] * sizeof(int32_t));
bwamem.cpp:    SMEM    *matchArray   = mmc->matchArray[tid];
bwamem.cpp:    int32_t *min_intv_ar  = mmc->min_intv_ar[tid];
bwamem.cpp:    int16_t *query_pos_ar = mmc->query_pos_ar[tid];
bwamem.cpp:    uint8_t *enc_qdb      = mmc->enc_qdb[tid];
bwamem.cpp:    int32_t *rid          = mmc->rid[tid];
bwamem.cpp:    int64_t  *wsize_mem   = &mmc->wsize_mem[tid];
bwamem.cpp:    tprof[MEM_COLLECT][tid] += __rdtsc() - tim; 
bwamem.cpp:    mem_chain_seeds(fmi, opt, fmi->idx->bns,
bwamem.cpp:    // tprof[MEM_CHAIN][tid] += __rdtsc() - tim;
bwamem.cpp:    /************** Post-processing of collected smems/chains ************/
bwamem.cpp:        chn->n = mem_chain_flt(opt, chn->n, chn->a, tid);
bwamem.cpp:    // tprof[MEM_ALN_M1][tid] += __rdtsc() - tim;
bwamem.cpp:        mem_flt_chained_seeds(opt, fmi->idx->bns, fmi->idx->pac, seq_, chn->n, chn->a);
bwamem.cpp:    // tprof[MEM_ALN_M2][tid] += __rdtsc() - tim;
bwamem.cpp:    /****************** Kernel 2: B-SWA *********************/
bwamem.cpp:                                  fmi->idx->bns,
bwamem.cpp:                                  fmi->idx->pac,
bwamem.cpp:    tprof[MEM_ALN2][tid] += __rdtsc() - tim;
bwamem.cpp:        for (int i = 0; i < chain->n; ++i)
bwamem.cpp:            mem_chain_t chn = chain->a[i];
bwamem.cpp:        regs[l].n = mem_sort_dedup_patch(opt, fmi->idx->bns,
bwamem.cpp:                                         fmi->idx->pac,
bwamem.cpp:            if (p->rid >= 0 && fmi->idx->bns->anns[p->rid].is_alt)
bwamem.cpp:                p->is_alt = 1;
bwamem.cpp:    // tprof[POST_SWA][tid] += __rdtsc() - tim;
bwamem.cpp:    mem_kernel2_core(w->fmi, w->opt, 
bwamem.cpp:                     w->seqs + seq_id,
bwamem.cpp:                     w->regs + seq_id,
bwamem.cpp:                     w->chain_ar + seq_id,
bwamem.cpp:                     &w->mmc,
bwamem.cpp:                     w->ref_string,
bwamem.cpp:    int seedBufSz = w->seedBufSize;
bwamem.cpp:    int memSize = w->nreads; 
bwamem.cpp:        seedBufSz = (memSize - seq_id) * AVG_SEEDS_PER_READ;
bwamem.cpp:    mem_kernel1_core(w->fmi, w->opt,
bwamem.cpp:                     w->seqs + seq_id,
bwamem.cpp:                     w->chain_ar + seq_id,
bwamem.cpp:                     w->seedBuf + seq_id * AVG_SEEDS_PER_READ,
bwamem.cpp:                     &(w->mmc),
bwamem.cpp:    SeqPair *seqPairArray = mmc->seqPairArrayLeft128[tid];
bwamem.cpp:    // SeqPair *seqPairArrayAux = mmc->seqPairArrayAux[tid];
bwamem.cpp:    SeqPair *seqPairArrayAux = mmc->seqPairArrayRight128[tid];
bwamem.cpp:        int xtra = s->h0;
bwamem.cpp:        seqPairArray[i] = seqPairArrayAux[i-pos8];
bwamem.cpp:    if (w->opt->flag & MEM_F_PE)
bwamem.cpp:            mem_sam_pe(w->opt, w->fmi->idx->bns,
bwamem.cpp:                       w->fmi->idx->pac, w->pes,
bwamem.cpp:                       (w->n_processed >> 1) + pos++,   // check!
bwamem.cpp:                       &w->seqs[i],
bwamem.cpp:                       &w->regs[i]);
bwamem.cpp:            free(w->regs[i].a);
bwamem.cpp:            free(w->regs[i+1].a);
bwamem.cpp:#else   // re-structured
bwamem.cpp:        // pre-processing
bwamem.cpp:            mem_sam_pe_batch_pre(w->opt, w->fmi->idx->bns,
bwamem.cpp:                                 w->fmi->idx->pac, w->pes,
bwamem.cpp:                                 (w->n_processed >> 1) + pos++,   // check!
bwamem.cpp:                                 &w->seqs[i],
bwamem.cpp:                                 &w->regs[i],
bwamem.cpp:                                 &w->mmc, 
bwamem.cpp:        // tprof[SAM1][tid] += __rdtsc() - tim;
bwamem.cpp:        int64_t pcnt8 = sort_classify(&w->mmc, pcnt, tid);
bwamem.cpp:        mem_sam_pe_batch(w->opt, &w->mmc, pcnt, pcnt8, aln, maxRefLen, maxQerLen, tid);     
bwamem.cpp:        // post-processing
bwamem.cpp:            mem_sam_pe_batch_post(w->opt, w->fmi->idx->bns,
bwamem.cpp:                                  w->fmi->idx->pac, w->pes,
bwamem.cpp:                                  (w->n_processed >> 1) + pos++,   // check!
bwamem.cpp:                                  &w->seqs[i],
bwamem.cpp:                                  &w->regs[i],
bwamem.cpp:                                  &w->mmc,
bwamem.cpp:            free(w->regs[i].a);
bwamem.cpp:            free(w->regs[i+1].a);
bwamem.cpp:        //tprof[SAM3][tid] += __rdtsc() - tim;      
bwamem.cpp:            mem_mark_primary_se(w->opt, w->regs[i].n,
bwamem.cpp:                                w->regs[i].a,
bwamem.cpp:                                w->n_processed + i);
bwamem.cpp:#if V17  // Feature from v0.7.17 of orig. bwa-mem
bwamem.cpp:            if (w->opt->flag & MEM_F_PRIMARY5) mem_reorder_primary5(w->opt->T, &w->regs[i]);            
bwamem.cpp:            mem_reg2sam(w->opt, w->fmi->idx->bns, w->fmi->idx->pac, &w->seqs[i],
bwamem.cpp:                        &w->regs[i], 0, 0);
bwamem.cpp:            free(w->regs[i].a);
bwamem.cpp:    //int n_ = (opt->flag & MEM_F_PE) ? n : n;   // this requires n%2==0
bwamem.cpp:    fprintf(stderr, "[0000] 1. Calling kt_for - worker_bwt\n");
bwamem.cpp:    fprintf(stderr, "[0000] 2. Calling kt_for - worker_aln\n");
bwamem.cpp:    tprof[WORKER10][0] += __rdtsc() - tim;      
bwamem.cpp:    if (opt->flag & MEM_F_PE) { // infer insert sizes if not provided
bwamem.cpp:            memcpy_bwamem(pes, 4 * sizeof(mem_pestat_t), pes0, 4 * sizeof(mem_pestat_t), __FILE__, __LINE__); // if pes0 != NULL, set the insert-size
bwamem.cpp:                    "l_pac: %ld, n: %d\n", w.fmi->idx->bns->l_pac, n);
bwamem.cpp:            mem_pestat(opt, w.fmi->idx->bns->l_pac, n, w.regs, pes); // otherwise, infer the insert size
bwamem.cpp:    fprintf(stderr, "[0000] 3. Calling kt_for - worker_sam\n");
bwamem.cpp:    tprof[WORKER20][0] += __rdtsc() - tim;
bwamem.cpp:            __func__, n, cputime() - ctime, realtime() - rtime);
bwamem.cpp:    tmp = opt->a + opt->b;
bwamem.cpp:    tmp = opt->o_del + opt->e_del > tmp? opt->o_del + opt->e_del : tmp;
bwamem.cpp:    tmp = opt->o_ins + opt->e_ins > tmp? opt->o_ins + opt->e_ins : tmp;
bwamem.cpp:    z->n = 0;
bwamem.cpp:        for (k = 0; k < z->n; ++k) {
bwamem.cpp:            int j = z->a[k];
bwamem.cpp:                int min_l = a[i].qe - a[i].qb < a[j].qe - a[j].qb? a[i].qe - a[i].qb : a[j].qe - a[j].qb;
bwamem.cpp:                if (e_min - b_max >= min_l * opt->mask_level) { // significant overlap
bwamem.cpp:                    if (a[j].score - a[i].score <= tmp && (a[j].is_alt || !a[i].is_alt))
bwamem.cpp:        if (k == z->n) kv_push(int, *z, i);
bwamem.cpp:        else a[i].secondary = z->a[k];
bwamem.cpp:        a[i].sub = a[i].alt_sc = 0, a[i].secondary = a[i].secondary_all = -1, a[i].hash = hash_64(id+i);
bwamem.cpp:        p->secondary_all = i; // keep the rank in the first round
bwamem.cpp:        if (!p->is_alt && p->secondary >= 0 && a[p->secondary].is_alt)
bwamem.cpp:            p->alt_sc = a[p->secondary].score;
bwamem.cpp:            } else a[i].secondary_all = -1;
bwamem.cpp:            for (i = 0; i < n_pri; ++i) a[i].sub = 0, a[i].secondary = -1;
bwamem.cpp:    int mapq, l, sub = a->sub? a->sub : opt->min_seed_len * opt->a;
bwamem.cpp:    sub = a->csub > sub? a->csub : sub;
bwamem.cpp:    if (sub >= a->score) return 0;
bwamem.cpp:    l = a->qe - a->qb > a->re - a->rb? a->qe - a->qb : a->re - a->rb;
bwamem.cpp:    identity = 1. - (double)(l * opt->a - a->score) / (opt->a + opt->b) / l;
bwamem.cpp:    if (a->score == 0) {
bwamem.cpp:    } else if (opt->mapQ_coef_len > 0) {
bwamem.cpp:        tmp = l < opt->mapQ_coef_len? 1. : opt->mapQ_coef_fac / log(l);
bwamem.cpp:        mapq = (int)(6.02 * (a->score - sub) / opt->a * tmp * tmp + .499);
bwamem.cpp:        mapq = (int)(MEM_MAPQ_COEF * (1. - (double)sub / a->score) * log(a->seedcov) + .499);
bwamem.cpp:    if (a->sub_n > 0) mapq -= (int)(4.343 * log(a->sub_n+1) + .499);
bwamem.cpp:    mapq = (int)(mapq * (1. - a->frac_rep) + .499);
bwamem.cpp:    int k, n_pri = 0, left_st = INT_MAX, left_k = -1;
bwamem.cpp:    for (k = 0; k < a->n; ++k)
bwamem.cpp:        if (a->a[k].secondary < 0 && !a->a[k].is_alt && a->a[k].score >= T) ++n_pri;
bwamem.cpp:    for (k = 0; k < a->n; ++k) {
bwamem.cpp:        mem_alnreg_t *p = &a->a[k];
bwamem.cpp:        if (p->secondary >= 0 || p->is_alt || p->score < T) continue;
bwamem.cpp:        if (p->qb < left_st) left_st = p->qb, left_k = k;
bwamem.cpp:    assert(a->a[0].secondary < 0);
bwamem.cpp:    t = a->a[0], a->a[0] = a->a[left_k], a->a[left_k] = t;
bwamem.cpp:    for (k = 1; k < a->n; ++k) { // update secondary and secondary_all
bwamem.cpp:        mem_alnreg_t *p = &a->a[k];
bwamem.cpp:        if (p->secondary == 0) p->secondary = left_k;
bwamem.cpp:        else if (p->secondary == left_k) p->secondary = 0;
bwamem.cpp:        if (p->secondary_all == 0) p->secondary_all = left_k;
bwamem.cpp:        else if (p->secondary_all == left_k) p->secondary_all = 0;
bwamem.cpp:    if (!(opt->flag & MEM_F_ALL))
bwamem.cpp:        XA = mem_gen_alt(opt, bns, pac, a, s->l_seq, s->seq);
bwamem.cpp:    for (k = l = 0; k < a->n; ++k)
bwamem.cpp:        mem_alnreg_t *p = &a->a[k];
bwamem.cpp:        if (p->score < opt->T) continue;
bwamem.cpp:        //fprintf(stderr, "%d %d %d %d\n", p->secondary, p->is_alt, opt->flag&MEM_F_ALL,
bwamem.cpp:        //      (p->secondary >= 0 && (p->is_alt || !(opt->flag&MEM_F_ALL))));
bwamem.cpp:        if (p->secondary >= 0 && (p->is_alt || !(opt->flag&MEM_F_ALL))) continue;
bwamem.cpp:        // assert(p->secondary < INT_MAX);
bwamem.cpp:        if (p->secondary >= 0 && p->secondary < INT_MAX && p->score < a->a[p->secondary].score * opt->drop_ratio) continue;
bwamem.cpp:        *q = mem_reg2aln(opt, bns, pac, s->l_seq, s->seq, p);
bwamem.cpp:        assert(q->rid >= 0); // this should not happen with the new code
bwamem.cpp:        q->XA = XA? XA[k] : 0;      
bwamem.cpp:        q->flag |= extra_flag; // flag secondary
bwamem.cpp:        if (p->secondary >= 0) q->sub = -1; // don't output sub-optimal score
bwamem.cpp:        if (l && p->secondary < 0) // if supplementary
bwamem.cpp:            q->flag |= (opt->flag&MEM_F_NO_MULTI)? 0x10000 : 0x800;
bwamem.cpp:        if (!(opt->flag & MEM_F_KEEP_SUPP_MAPQ) && l && !p->is_alt && q->mapq > aa.a[0].mapq)
bwamem.cpp:            q->mapq = aa.a[0].mapq; // lower mapq for supplementary mappings, unless -5 or -q is applied
bwamem.cpp:        if (l && !p->is_alt && q->mapq > aa.a[0].mapq) q->mapq = aa.a[0].mapq;
bwamem.cpp:        t = mem_reg2aln(opt, bns, pac, s->l_seq, s->seq, 0);
bwamem.cpp:    s->sam = str.s;
bwamem.cpp:        for (k = 0; k < a->n; ++k) free(XA[k]);
bwamem.cpp:    if (p->n_cigar) { // aligned
bwamem.cpp:        for (i = 0; i < p->n_cigar; ++i) {
bwamem.cpp:            int c = p->cigar[i]&0xf;
bwamem.cpp:            if (!(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt && (c == 3 || c == 4))
bwamem.cpp:            kputw(p->cigar[i]>>4, str); kputc("MIDSH"[c], str);
bwamem.cpp:    p->flag |= m? 0x1 : 0; // is paired in sequencing
bwamem.cpp:    p->flag |= p->rid < 0? 0x4 : 0; // is mapped
bwamem.cpp:    p->flag |= m && m->rid < 0? 0x8 : 0; // is mate mapped
bwamem.cpp:    if (p->rid < 0 && m && m->rid >= 0) // copy mate to alignment
bwamem.cpp:        p->rid = m->rid, p->pos = m->pos, p->is_rev = m->is_rev, p->n_cigar = 0;
bwamem.cpp:    if (m && m->rid < 0 && p->rid >= 0) // copy alignment to mate
bwamem.cpp:        m->rid = p->rid, m->pos = p->pos, m->is_rev = p->is_rev, m->n_cigar = 0;
bwamem.cpp:    p->flag |= p->is_rev? 0x10 : 0; // is on the reverse strand
bwamem.cpp:    p->flag |= m && m->is_rev? 0x20 : 0; // is mate on the reverse strand
bwamem.cpp:    l_name = strlen(s->name);
bwamem.cpp:    ks_resize(str, str->l + s->l_seq + l_name + (s->qual? s->l_seq : 0) + 20);
bwamem.cpp:    kputsn(s->name, l_name, str); kputc('\t', str); // QNAME
bwamem.cpp:    kputw((p->flag&0xffff) | (p->flag&0x10000? 0x100 : 0), str); kputc('\t', str); // FLAG
bwamem.cpp:    if (p->rid >= 0) { // with coordinate
bwamem.cpp:        kputs(bns->anns[p->rid].name, str); kputc('\t', str); // RNAME
bwamem.cpp:        kputl(p->pos + 1, str); kputc('\t', str); // POS
bwamem.cpp:        kputw(p->mapq, str); kputc('\t', str); // MAPQ
bwamem.cpp:        if (p->n_cigar) { // aligned
bwamem.cpp:            for (i = 0; i < p->n_cigar; ++i) {
bwamem.cpp:                int c = p->cigar[i]&0xf;
bwamem.cpp:                if (!(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt && (c == 3 || c == 4))
bwamem.cpp:                kputw(p->cigar[i]>>4, str); kputc("MIDSH"[c], str);
bwamem.cpp:    if (m && m->rid >= 0) {
bwamem.cpp:        if (p->rid == m->rid) kputc('=', str);
bwamem.cpp:        else kputs(bns->anns[m->rid].name, str);
bwamem.cpp:        kputl(m->pos + 1, str); kputc('\t', str);
bwamem.cpp:        if (p->rid == m->rid) {
bwamem.cpp:            int64_t p0 = p->pos + (p->is_rev? get_rlen(p->n_cigar, p->cigar) - 1 : 0);
bwamem.cpp:            int64_t p1 = m->pos + (m->is_rev? get_rlen(m->n_cigar, m->cigar) - 1 : 0);
bwamem.cpp:            if (m->n_cigar == 0 || p->n_cigar == 0) kputc('0', str);
bwamem.cpp:            else kputl(-(p0 - p1 + (p0 > p1? 1 : p0 < p1? -1 : 0)), str);
bwamem.cpp:    if (p->flag & 0x100) { // for secondary alignments, don't write SEQ and QUAL
bwamem.cpp:    } else if (!p->is_rev) { // the forward strand
bwamem.cpp:        int i, qb = 0, qe = s->l_seq;
bwamem.cpp:        if (p->n_cigar && which && !(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt) { // have cigar && not the primary alignment && not softclip all
bwamem.cpp:            if ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qb += p->cigar[0]>>4;
bwamem.cpp:            if ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qe -= p->cigar[p->n_cigar-1]>>4;
bwamem.cpp:        ks_resize(str, str->l + (qe - qb) + 1);
bwamem.cpp:        for (i = qb; i < qe; ++i) str->s[str->l++] = "ACGTN"[(int)s->seq[i]];
bwamem.cpp:        if (s->qual) { // printf qual
bwamem.cpp:            ks_resize(str, str->l + (qe - qb) + 1);
bwamem.cpp:            for (i = qb; i < qe; ++i) str->s[str->l++] = s->qual[i];
bwamem.cpp:            str->s[str->l] = 0;
bwamem.cpp:        int i, qb = 0, qe = s->l_seq;
bwamem.cpp:        if (p->n_cigar && which && !(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt) {
bwamem.cpp:            if ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qe -= p->cigar[0]>>4;
bwamem.cpp:            if ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qb += p->cigar[p->n_cigar-1]>>4;
bwamem.cpp:        ks_resize(str, str->l + (qe - qb) + 1);
bwamem.cpp:        for (i = qe-1; i >= qb; --i) str->s[str->l++] = "TGCAN"[(int)s->seq[i]];
bwamem.cpp:        if (s->qual) { // printf qual
bwamem.cpp:            ks_resize(str, str->l + (qe - qb) + 1);
bwamem.cpp:            for (i = qe-1; i >= qb; --i) str->s[str->l++] = s->qual[i];
bwamem.cpp:            str->s[str->l] = 0;
bwamem.cpp:    if (p->n_cigar) {
bwamem.cpp:        kputsn("\tNM:i:", 6, str); kputw(p->NM, str);
bwamem.cpp:        kputsn("\tMD:Z:", 6, str); kputs((char*)(p->cigar + p->n_cigar), str);
bwamem.cpp:    if (m && m->n_cigar) { kputsn("\tMC:Z:", 6, str); add_cigar(opt, m, str, which); }
bwamem.cpp:    if (p->score >= 0) { kputsn("\tAS:i:", 6, str); kputw(p->score, str); }
bwamem.cpp:    if (p->sub >= 0) { kputsn("\tXS:i:", 6, str); kputw(p->sub, str); }
bwamem.cpp:    if (!(p->flag & 0x100)) { // not multi-hit
bwamem.cpp:                if (i == which || (r->flag&0x100)) continue; // proceed if: 1) different from the current; 2) not shadowed multi hit
bwamem.cpp:                kputs(bns->anns[r->rid].name, str); kputc(',', str);
bwamem.cpp:                kputl(r->pos+1, str); kputc(',', str);
bwamem.cpp:                kputc("+-"[r->is_rev], str); kputc(',', str);
bwamem.cpp:                for (k = 0; k < r->n_cigar; ++k) {
bwamem.cpp:                    kputw(r->cigar[k]>>4, str); kputc("MIDSH"[r->cigar[k]&0xf], str);
bwamem.cpp:                kputc(',', str); kputw(r->mapq, str);
bwamem.cpp:                kputc(',', str); kputw(r->NM, str);
bwamem.cpp:        if (p->alt_sc > 0)
bwamem.cpp:            ksprintf(str, "\tpa:f:%.3f", (double)p->score / p->alt_sc);
bwamem.cpp:    if (p->XA) { kputsn("\tXA:Z:", 6, str); kputs(p->XA, str); }
bwamem.cpp:    if (s->comment) { kputc('\t', str); kputs(s->comment, str); }
bwamem.cpp:    if ((opt->flag&MEM_F_REF_HDR) && p->rid >= 0 && bns->anns[p->rid].anno != 0 && bns->anns[p->rid].anno[0] != 0) {
bwamem.cpp:        tmp = str->l;
bwamem.cpp:        kputs(bns->anns[p->rid].anno, str);
bwamem.cpp:        for (i = tmp; i < str->l; ++i) // replace TAB in the comment to SPACE
bwamem.cpp:            if (str->s[i] == '\t') str->s[i] = ' ';
bwamem.cpp:    int i, w2, tmp, qb, qe, NM, score, is_rev, last_sc = -(1<<30), l_MD;
bwamem.cpp:    if (ar == 0 || ar->rb < 0 || ar->re < 0) { // generate an unmapped record
bwamem.cpp:        a.rid = -1; a.pos = -1; a.flag |= 0x4;
bwamem.cpp:    qb = ar->qb, qe = ar->qe;
bwamem.cpp:    rb = ar->rb, re = ar->re;
bwamem.cpp:    a.mapq = ar->secondary < 0? mem_approx_mapq_se(opt, ar) : 0;
bwamem.cpp:    if (ar->secondary >= 0) a.flag |= 0x100; // secondary alignment
bwamem.cpp:    tmp = infer_bw(qe - qb, re - rb, ar->truesc, opt->a, opt->o_del, opt->e_del);
bwamem.cpp:    w2  = infer_bw(qe - qb, re - rb, ar->truesc, opt->a, opt->o_ins, opt->e_ins);
bwamem.cpp:    if (bwa_verbose >= 4) fprintf(stderr, "* Band width: inferred=%d, cmd_opt=%d, alnreg=%d\n", w2, opt->w, ar->w);
bwamem.cpp:    if (w2 > opt->w) w2 = w2 < ar->w? w2 : ar->w;
bwamem.cpp:        w2 = w2 < opt->w<<2? w2 : opt->w<<2;
bwamem.cpp:        a.cigar = bwa_gen_cigar2(opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, w2, bns->l_pac, pac, qe - qb, (uint8_t*)&query[qb], rb, re, &score, &a.n_cigar, &NM);
bwamem.cpp:        if (bwa_verbose >= 4) fprintf(stderr, "* Final alignment: w2=%d, global_sc=%d, local_sc=%d\n", w2, score, ar->truesc);
bwamem.cpp:        if (score == last_sc || w2 == opt->w<<2) break; // it is possible that global alignment and local alignment give different scores
bwamem.cpp:    } while (++i < 3 && score < ar->truesc - opt->a);
bwamem.cpp:    pos = bns_depos(bns, rb < bns->l_pac? rb : re - 1, &is_rev);
bwamem.cpp:            --a.n_cigar;
bwamem.cpp:        } else if ((a.cigar[a.n_cigar-1]&0xf) == 2) {
bwamem.cpp:            --a.n_cigar;
bwamem.cpp:        clip5 = is_rev? l_query - qe : qb;
bwamem.cpp:        clip3 = is_rev? qb : l_query - qe;
bwamem.cpp:            memmove(a.cigar+1, a.cigar, a.n_cigar * 4 + l_MD); // make room for 5'-end clipping
bwamem.cpp:            memmove(a.cigar + a.n_cigar + 1, a.cigar + a.n_cigar, l_MD); // make room for 3'-end clipping
bwamem.cpp:    assert(a.rid == ar->rid);
bwamem.cpp:    a.pos = pos - bns->anns[a.rid].offset;
bwamem.cpp:    a.score = ar->score; a.sub = ar->sub > ar->csub? ar->sub : ar->csub;
bwamem.cpp:    a.is_alt = ar->is_alt; a.alt_sc = ar->alt_sc;
bwamem.cpp: * Basic hit->SAM conversion *
bwamem.cpp:    if (l1 == l2 && l1 * a - score < (q + r - a)<<1) return 0; // to get equal alignment length, we need at least two gaps
bwamem.cpp:    w = ((double)((l1 < l2? l1 : l2) * a - score - q) / r + 2.);
bwamem.cpp:    if (w < abs(l1 - l2)) w = abs(l1 - l2);
bwamem.cpp:        *len = end - beg;
bwamem.cpp:        assert(end-beg < BATCH_SIZE * SEEDS_PER_READ * sizeof(SeqPair));
bwamem.cpp:        //seq = (uint8_t*) malloc(end - beg);
bwamem.cpp:            int64_t beg_f = (l_pac<<1) - 1 - end;
bwamem.cpp:            int64_t end_f = (l_pac<<1) - 1 - beg;
bwamem.cpp:            for (k = end_f; k > beg_f; --k) {
bwamem.cpp:                seq[l++] = 3 - _get_pac(pac, k);
bwamem.cpp:                assert(seq[l-1] == ref_string[beg + l - 1]);
bwamem.cpp:                assert(seq[l-1] == ref_string[k]);
bwamem.cpp:    } else *len = 0; // if bridging the forward-reverse boundary, return nothing
bwamem.cpp:    far_beg = bns->anns[*rid].offset;
bwamem.cpp:    far_end = far_beg + bns->anns[*rid].len;
bwamem.cpp:        far_beg = (bns->l_pac<<1) - far_end;
bwamem.cpp:        far_end = (bns->l_pac<<1) - tmp;
bwamem.cpp:    seq = bns_get_seq_v2(bns->l_pac, pac, *beg, *end, &len, ref_string, seqb);
bwamem.cpp:    if (seq == 0 || *end - *beg != len) {
bwamem.cpp:    assert(seq && *end - *beg == len); // assertion failure should never happen
bwamem.cpp:                SeqPair spt = pairArray[arr[pos]-1];
bwamem.cpp:    SeqPair *seqPairArrayAux      = mmc->seqPairArrayAux[tid];
bwamem.cpp:    SeqPair *seqPairArrayLeft128  = mmc->seqPairArrayLeft128[tid];
bwamem.cpp:    SeqPair *seqPairArrayRight128 = mmc->seqPairArrayRight128[tid];
bwamem.cpp:    int64_t *wsize_pair = &(mmc->wsize[tid]);
bwamem.cpp:    uint8_t *seqBufLeftRef  = mmc->seqBufLeftRef[tid*CACHE_LINE]; 
bwamem.cpp:    uint8_t *seqBufRightRef = mmc->seqBufRightRef[tid*CACHE_LINE];
bwamem.cpp:    uint8_t *seqBufLeftQer  = mmc->seqBufLeftQer[tid*CACHE_LINE]; 
bwamem.cpp:    uint8_t *seqBufRightQer = mmc->seqBufRightQer[tid*CACHE_LINE];
bwamem.cpp:    int64_t *wsize_buf_ref = &(mmc->wsize_buf_ref[tid*CACHE_LINE]);
bwamem.cpp:    int64_t *wsize_buf_qer = &(mmc->wsize_buf_qer[tid*CACHE_LINE]);
bwamem.cpp:    // int32_t *lim_g = mmc->lim + (BATCH_SIZE + 32) * tid;
bwamem.cpp:    int32_t *lim_g = mmc->lim[tid];
bwamem.cpp:    int64_t l_pac = bns->l_pac, rmax[8] __attribute__((aligned(64)));
bwamem.cpp:        av->m = 0;
bwamem.cpp:        for (int j=0; j<chn->n; j++) {
bwamem.cpp:            c = &chn->a[j]; av->m += c->n;
bwamem.cpp:        av->a = (mem_alnreg_t*)calloc(av->m, sizeof(mem_alnreg_t));
bwamem.cpp:        for (int j=0; j<chn->n; j++)
bwamem.cpp:            c = &chn->a[j];
bwamem.cpp:            assert(c->seqid == l);
bwamem.cpp:            if (c->n == 0) continue;
bwamem.cpp:            for (int i = 0; i < c->n; ++i) {
bwamem.cpp:                const mem_seed_t *t = &c->seeds[i];
bwamem.cpp:                b = t->rbeg - (t->qbeg + cal_max_gap(opt, t->qbeg));
bwamem.cpp:                e = t->rbeg + t->len + ((l_query - t->qbeg - t->len) +
bwamem.cpp:                                        cal_max_gap(opt, l_query - t->qbeg - t->len));
bwamem.cpp:                if (t->len > max) max = t->len;
bwamem.cpp:                if (c->seeds[0].rbeg < l_pac) rmax[1] = l_pac;
bwamem.cpp:                                        c->seeds[0].rbeg,
bwamem.cpp:                assert(c->rid == rid);
bwamem.cpp:            // assert(c->n < MAX_SEEDS_PER_READ);  // temp
bwamem.cpp:            if (c->n > srt_size) {
bwamem.cpp:                srt_size = c->n + 10;
bwamem.cpp:            for (int i = 0; i < c->n; ++i) 
bwamem.cpp:                srt[i] = (uint64_t)c->seeds[i].score<<32 | i;
bwamem.cpp:            if (c->n > 1) 
bwamem.cpp:                ks_introsort_64(c->n, srt);
bwamem.cpp:            // assert((spos + c->n) < SEEDS_PER_READ * FAC * nseq);
bwamem.cpp:            if ((spos + c->n) > SEEDS_PER_READ * fac * nseq) {
bwamem.cpp:            for (int i = 0; i < c->n; ++i)
bwamem.cpp:            lim_g[l+1] += c->n;
bwamem.cpp:            for (int k=c->n-1; k >= 0; k--)
bwamem.cpp:                s = &c->seeds[(uint32_t)srt[k]];
bwamem.cpp:                a = &av->a[av->n++];
bwamem.cpp:                s->aln = av->n-1;
bwamem.cpp:                a->w = opt->w;
bwamem.cpp:                a->score = a->truesc = -1;
bwamem.cpp:                a->rid = c->rid;
bwamem.cpp:                a->frac_rep = c->frac_rep;
bwamem.cpp:                a->seedlen0 = s->len;
bwamem.cpp:                a->c = c; //ptr
bwamem.cpp:                a->rb = a->qb = a->re = a->qe = H0_;
bwamem.cpp:                if (s->qbeg)  // left extension
bwamem.cpp:                    sp.h0 = s->len * opt->a;
bwamem.cpp:                    sp.seqid = c->seqid;
bwamem.cpp:                    sp.regid = av->n - 1;
bwamem.cpp:                        fprintf(stderr, "[0000][%0.4d] Re-allocating seqPairArrays, in Left\n", tid);
bwamem.cpp:                        mmc->seqPairArrayAux[tid] = seqPairArrayAux;
bwamem.cpp:                        mmc->seqPairArrayLeft128[tid] = seqPairArrayLeft128;
bwamem.cpp:                        mmc->seqPairArrayRight128[tid] = seqPairArrayRight128;
bwamem.cpp:                    leftQerOffset += s->qbeg;
bwamem.cpp:                        fprintf(stderr, "[%0.4d] Re-allocating (doubling) seqBufQers in %s (left)\n",
bwamem.cpp:                        mmc->seqBufLeftQer[tid*CACHE_LINE] = seqBufLeftQer = seqBufQer_;
bwamem.cpp:                        mmc->seqBufRightQer[tid*CACHE_LINE] = seqBufRightQer = seqBufQer_;      
bwamem.cpp:                    for (int i = 0; i < s->qbeg; ++i) qs[i] = query[s->qbeg - 1 - i];
bwamem.cpp:                    tmp = s->rbeg - rmax[0];
bwamem.cpp:                        fprintf(stderr, "[%0.4d] Re-allocating (doubling) seqBufRefs in %s (left)\n",
bwamem.cpp:                        mmc->seqBufLeftRef[tid*CACHE_LINE] = seqBufLeftRef = seqBufRef_;
bwamem.cpp:                        mmc->seqBufRightRef[tid*CACHE_LINE] = seqBufRightRef = seqBufRef_;              
bwamem.cpp:                    for (int64_t i = 0; i < tmp; ++i) rs[i] = rseq[tmp - 1 - i]; //seq1
bwamem.cpp:                    sp.len2 = s->qbeg;
bwamem.cpp:                    int minval = sp.h0 + min_(sp.len1, sp.len2) * opt->a;
bwamem.cpp:                    a->qb = s->qbeg; a->rb = s->rbeg;
bwamem.cpp:                    a->score = a->truesc = s->len * opt->a, a->qb = 0, a->rb = s->rbeg;
bwamem.cpp:                if (s->qbeg + s->len != l_query)  // right extension
bwamem.cpp:                    int64_t qe = s->qbeg + s->len;
bwamem.cpp:                    int64_t re = s->rbeg + s->len - rmax[0];
bwamem.cpp:                    sp.seqid = c->seqid;
bwamem.cpp:                    sp.regid = av->n - 1;
bwamem.cpp:                        fprintf(stderr, "[0000] [%0.4d] Re-allocating seqPairArrays Right\n", tid);
bwamem.cpp:                        mmc->seqPairArrayAux[tid] = seqPairArrayAux;
bwamem.cpp:                        mmc->seqPairArrayLeft128[tid] = seqPairArrayLeft128;
bwamem.cpp:                        mmc->seqPairArrayRight128[tid] = seqPairArrayRight128;
bwamem.cpp:                    sp.len2 = l_query - qe;
bwamem.cpp:                    sp.len1 = rmax[1] - rmax[0] - re;
bwamem.cpp:                        fprintf(stderr, "[%0.4d] Re-allocating (doubling) seqBufQers in %s (right)\n",
bwamem.cpp:                        mmc->seqBufLeftQer[tid*CACHE_LINE] = seqBufLeftQer = seqBufQer_;
bwamem.cpp:                        mmc->seqBufRightQer[tid*CACHE_LINE] = seqBufRightQer = seqBufQer_;      
bwamem.cpp:                        fprintf(stderr, "[%0.4d] Re-allocating (doubling) seqBufRefs in %s (right)\n",
bwamem.cpp:                        mmc->seqBufLeftRef[tid*CACHE_LINE] = seqBufLeftRef = seqBufRef_;
bwamem.cpp:                        mmc->seqBufRightRef[tid*CACHE_LINE] = seqBufRightRef = seqBufRef_;              
bwamem.cpp:                    int minval = sp.h0 + min_(sp.len1, sp.len2) * opt->a;
bwamem.cpp:                    a->qe = qe; a->re = rmax[0] + re;
bwamem.cpp:                    a->qe = l_query, a->re = s->rbeg + s->len;
bwamem.cpp:                    if (a->rb != H0_ && a->qb != H0_)
bwamem.cpp:                        for (i = 0, a->seedcov = 0; i < c->n; ++i)
bwamem.cpp:                            const mem_seed_t *t = &c->seeds[i];
bwamem.cpp:                            if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                                t->rbeg >= a->rb && t->rbeg + t->len <= a->re) // seed fully contained
bwamem.cpp:                                a->seedcov += t->len;
bwamem.cpp:            // tprof[MEM_ALN2_DOWN1][tid] += __rdtsc() - tim;
bwamem.cpp:    // tprof[MEM_ALN2_UP][tid] += __rdtsc() - timUP;
bwamem.cpp:                    numPairsLeft128, numPairsLeft16, numPairsLeft1, opt->a);
bwamem.cpp:    // Now, process all the collected seq-pairs
bwamem.cpp:    BandedPairWiseSW bswLeft(opt->o_del, opt->e_del, opt->o_ins,
bwamem.cpp:                             opt->e_ins, opt->zdrop, opt->pen_clip5,
bwamem.cpp:                             opt->mat, opt->a, opt->b, nthreads);
bwamem.cpp:    BandedPairWiseSW bswRight(opt->o_del, opt->e_del, opt->o_ins,
bwamem.cpp:                              opt->e_ins, opt->zdrop, opt->pen_clip3,
bwamem.cpp:                              opt->mat, opt->a, opt->b, nthreads);
bwamem.cpp:        int32_t w = opt->w << i;
bwamem.cpp:        // tprof[MEM_ALN2_B][tid] += __rdtsc() - tim;
bwamem.cpp:            a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:            int prev = a->score;
bwamem.cpp:            a->score = sp->score;
bwamem.cpp:            if (a->score == prev || sp->max_off < (w >> 1) + (w >> 2) ||
bwamem.cpp:                if (sp->gscore <= 0 || sp->gscore <= a->score - opt->pen_clip5) {
bwamem.cpp:                    a->qb -= sp->qle; a->rb -= sp->tle;
bwamem.cpp:                    a->truesc = a->score;
bwamem.cpp:                    a->qb = 0; a->rb -= sp->gtle;
bwamem.cpp:                    a->truesc = sp->gscore;
bwamem.cpp:                a->w = max_(a->w, w);
bwamem.cpp:                if (a->rb != H0_ && a->qb != H0_ && a->qe != H0_ && a->re != H0_)
bwamem.cpp:                    for (i = 0, a->seedcov = 0; i < a->c->n; ++i){
bwamem.cpp:                        const mem_seed_t *t = &(a->c->seeds[i]);
bwamem.cpp:                        if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                            t->rbeg >= a->rb && t->rbeg + t->len <= a->re)
bwamem.cpp:                            a->seedcov += t->len;
bwamem.cpp:    //****************** Left - vector int16 ***********************
bwamem.cpp:        int32_t w = opt->w << i;
bwamem.cpp:        // tprof[MEM_ALN2_B][tid] += __rdtsc() - tim;
bwamem.cpp:            a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:            int prev = a->score;
bwamem.cpp:            a->score = sp->score;
bwamem.cpp:            if (a->score == prev || sp->max_off < (w >> 1) + (w >> 2) ||
bwamem.cpp:                if (sp->gscore <= 0 || sp->gscore <= a->score - opt->pen_clip5) {
bwamem.cpp:                    a->qb -= sp->qle; a->rb -= sp->tle;
bwamem.cpp:                    a->truesc = a->score;
bwamem.cpp:                    a->qb = 0; a->rb -= sp->gtle;
bwamem.cpp:                    a->truesc = sp->gscore;
bwamem.cpp:                a->w = max_(a->w, w);
bwamem.cpp:                if (a->rb != H0_ && a->qb != H0_ && a->qe != H0_ && a->re != H0_)
bwamem.cpp:                    for (i = 0, a->seedcov = 0; i < a->c->n; ++i){
bwamem.cpp:                        const mem_seed_t *t = &(a->c->seeds[i]);
bwamem.cpp:                        if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                            t->rbeg >= a->rb && t->rbeg + t->len <= a->re)
bwamem.cpp:                            a->seedcov += t->len;
bwamem.cpp:    //****************** Left - vector int8 ***********************
bwamem.cpp:        int32_t w = opt->w << i;
bwamem.cpp:        // tprof[MEM_ALN2_D][tid] += __rdtsc() - tim;
bwamem.cpp:            a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:            int prev = a->score;
bwamem.cpp:            a->score = sp->score;
bwamem.cpp:            if (a->score == prev || sp->max_off < (w >> 1) + (w >> 2) ||
bwamem.cpp:                if (sp->gscore <= 0 || sp->gscore <= a->score - opt->pen_clip5) {
bwamem.cpp:                    a->qb -= sp->qle; a->rb -= sp->tle;
bwamem.cpp:                    a->truesc = a->score;
bwamem.cpp:                    a->qb = 0; a->rb -= sp->gtle;
bwamem.cpp:                    a->truesc = sp->gscore;
bwamem.cpp:                a->w = max_(a->w, w);
bwamem.cpp:                if (a->rb != H0_ && a->qb != H0_ && a->qe != H0_ && a->re != H0_)
bwamem.cpp:                    for (i = 0, a->seedcov = 0; i < a->c->n; ++i){
bwamem.cpp:                        const mem_seed_t *t = &(a->c->seeds[i]);
bwamem.cpp:                        if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                            t->rbeg >= a->rb && t->rbeg + t->len <= a->re)
bwamem.cpp:                            a->seedcov += t->len;
bwamem.cpp:    // tprof[CLEFT][tid] += __rdtsc() - timL;
bwamem.cpp:        a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:        sp->h0 = a->score;
bwamem.cpp:                    hist, numPairsRight128, numPairsRight16, numPairsRight1, opt->a);
bwamem.cpp:        int32_t w = opt->w << i;
bwamem.cpp:        // tprof[MEM_ALN2_C][tid] += __rdtsc() - tim;
bwamem.cpp:            a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:            int prev = a->score;
bwamem.cpp:            a->score = sp->score;
bwamem.cpp:            if (a->score == prev || sp->max_off < (w >> 1) + (w >> 2) ||
bwamem.cpp:                if (sp->gscore <= 0 || sp->gscore <= a->score - opt->pen_clip3) {
bwamem.cpp:                    a->qe += sp->qle, a->re += sp->tle;
bwamem.cpp:                    a->truesc += a->score - sp->h0;
bwamem.cpp:                    int l_query = seq_[sp->seqid].l_seq;
bwamem.cpp:                    a->qe = l_query, a->re += sp->gtle;
bwamem.cpp:                    a->truesc += sp->gscore - sp->h0;
bwamem.cpp:                a->w = max_(a->w, w);
bwamem.cpp:                if (a->rb != H0_ && a->qb != H0_ && a->qe != H0_ && a->re != H0_)
bwamem.cpp:                    for (i = 0, a->seedcov = 0; i < a->c->n; ++i) {
bwamem.cpp:                        const mem_seed_t *t = &a->c->seeds[i];
bwamem.cpp:                        if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                            t->rbeg >= a->rb && t->rbeg + t->len <= a->re)
bwamem.cpp:                            a->seedcov += t->len;
bwamem.cpp:    // ************************* Right - vector int16 **********************
bwamem.cpp:        int32_t w = opt->w << i;
bwamem.cpp:        // tprof[MEM_ALN2_C][tid] += __rdtsc() - tim;
bwamem.cpp:            a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:            int prev = a->score;
bwamem.cpp:            a->score = sp->score;
bwamem.cpp:            if (a->score == prev || sp->max_off < (w >> 1) + (w >> 2) ||
bwamem.cpp:                if (sp->gscore <= 0 || sp->gscore <= a->score - opt->pen_clip3) {
bwamem.cpp:                    a->qe += sp->qle, a->re += sp->tle;
bwamem.cpp:                    a->truesc += a->score - sp->h0;
bwamem.cpp:                    int l_query = seq_[sp->seqid].l_seq;
bwamem.cpp:                    a->qe = l_query, a->re += sp->gtle;
bwamem.cpp:                    a->truesc += sp->gscore - sp->h0;
bwamem.cpp:                a->w = max_(a->w, w);
bwamem.cpp:                if (a->rb != H0_ && a->qb != H0_ && a->qe != H0_ && a->re != H0_)
bwamem.cpp:                    for (i = 0, a->seedcov = 0; i < a->c->n; ++i) {
bwamem.cpp:                        const mem_seed_t *t = &a->c->seeds[i];
bwamem.cpp:                        if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                            t->rbeg >= a->rb && t->rbeg + t->len <= a->re)
bwamem.cpp:                            a->seedcov += t->len;
bwamem.cpp:        int32_t w = opt->w << i;
bwamem.cpp:        // tprof[MEM_ALN2_E][tid] += __rdtsc() - tim;
bwamem.cpp:            a = &(av_v[sp->seqid].a[sp->regid]); // prev
bwamem.cpp:            int prev = a->score;
bwamem.cpp:            a->score = sp->score;
bwamem.cpp:            if (a->score == prev || sp->max_off < (w >> 1) + (w >> 2) ||
bwamem.cpp:                if (sp->gscore <= 0 || sp->gscore <= a->score - opt->pen_clip3) {
bwamem.cpp:                    a->qe += sp->qle, a->re += sp->tle;
bwamem.cpp:                    a->truesc += a->score - sp->h0;
bwamem.cpp:                    int l_query = seq_[sp->seqid].l_seq;
bwamem.cpp:                    a->qe = l_query, a->re += sp->gtle;
bwamem.cpp:                    a->truesc += sp->gscore - sp->h0;
bwamem.cpp:                a->w = max_(a->w, w);
bwamem.cpp:                if (a->rb != H0_ && a->qb != H0_ && a->qe != H0_ && a->re != H0_)
bwamem.cpp:                    for (i = 0, a->seedcov = 0; i < a->c->n; ++i) {
bwamem.cpp:                        const mem_seed_t *t = &a->c->seeds[i];
bwamem.cpp:                        if (t->qbeg >= a->qb && t->qbeg + t->len <= a->qe &&
bwamem.cpp:                            t->rbeg >= a->rb && t->rbeg + t->len <= a->re)
bwamem.cpp:                            a->seedcov += t->len;
bwamem.cpp:    // tprof[CRIGHT][tid] += __rdtsc() - timR;
bwamem.cpp:        lim_g[l] += lim_g[l-1];
bwamem.cpp:        for (int j=0; j<chn->n; j++)
bwamem.cpp:            c = &chn->a[j];
bwamem.cpp:            assert(c->seqid == l);
bwamem.cpp:            s_end = s_start + c->n;
bwamem.cpp:            s_start += c->n;
bwamem.cpp:            for (k = c->n-1; k >= 0; k--)
bwamem.cpp:                s = &c->seeds[srt2[k]];
bwamem.cpp:                for (i = 0; i < av->n && v < lim[l]; ++i)  // test whether extension has been made before
bwamem.cpp:                    mem_alnreg_t *p = &av->a[i];
bwamem.cpp:                    if (p->qb == -1 && p->qe == -1) {
bwamem.cpp:                    if (s->rbeg < p->rb || s->rbeg + s->len > p->re || s->qbeg < p->qb
bwamem.cpp:                        || s->qbeg + s->len > p->qe) {
bwamem.cpp:                    if (s->len - p->seedlen0 > .1 * l_query) { v++; continue;}
bwamem.cpp:                    qd = s->qbeg - p->qb; rd = s->rbeg - p->rb;
bwamem.cpp:                    w = max_gap < p->w? max_gap : p->w; // bounded by the band width
bwamem.cpp:                    if (qd - rd < w && rd - qd < w) break; // the seed is "around" a previous hit
bwamem.cpp:                    qd = p->qe - (s->qbeg + s->len); rd = p->re - (s->rbeg + s->len);
bwamem.cpp:                    w = max_gap < p->w? max_gap : p->w;
bwamem.cpp:                    if (qd - rd < w && rd - qd < w) break;
bwamem.cpp:                    for (v = k + 1; v < c->n; ++v)
bwamem.cpp:                        t = &c->seeds[srt2[v]];
bwamem.cpp:                        //if (t->done == H0_) continue;  //check for interferences!!!
bwamem.cpp:                        if (t->len < s->len * .95) continue; 
bwamem.cpp:                        if (s->qbeg <= t->qbeg && s->qbeg + s->len - t->qbeg >= s->len>>2 &&
bwamem.cpp:                            t->qbeg - s->qbeg != t->rbeg - s->rbeg) break;
bwamem.cpp:                        if (t->qbeg <= s->qbeg && t->qbeg + t->len - s->qbeg >= s->len>>2 &&
bwamem.cpp:                            s->qbeg - t->qbeg != s->rbeg - t->rbeg) break;
bwamem.cpp:                    if (v == c->n) {                  // no overlapping seeds; then skip extension
bwamem.cpp:                        mem_alnreg_t *ar = &(av_v[l].a[s->aln]);
bwamem.cpp:                        ar->qb = ar->qe = -1;         // purge the alingment
bwamem.cpp:    // tprof[MEM_ALN2_DOWN][tid] += __rdtsc() - tim;    
memcpy_bwamem.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
memcpy_bwamem.cpp:        int64_t bytes_remaining = smax - bytes_copied;
memcpy_bwamem.cpp:        int64_t dest_bytes_remaining = dmax - bytes_copied;
memcpy_bwamem.cpp:// memcpy_bwamem_enc(str->enc_s, str->l, str->m - str->l, ks->enc_buf, ks->begin, i - ks->begin, __FILE__, __LINE__);
memcpy_bwamem.cpp:        int64_t bytes_remaining = smax - bytes_copied;
memcpy_bwamem.cpp:        int64_t dest_bytes_remaining = dmax - bytes_copied;
memcpy_bwamem.cpp:// // memcpy_bwamem_enc(str->enc_s, str->l, str->m - str->l, ks->enc_buf, ks->begin, i - ks->begin, __FILE__, __LINE__);
memcpy_bwamem.cpp://         int64_t bytes_remaining = smax - bytes_copied;
memcpy_bwamem.cpp://         int64_t dest_bytes_remaining = dmax - bytes_copied;
utils.cpp:	if (strcmp(fn, "-") == 0)
utils.cpp:	if (strcmp(fn, "-") == 0) {
utils.cpp:	if (-1 == ret)
utils.cpp:	return r.ru_utime.tv_sec + r.ru_stime.tv_sec + 1e-6 * (r.ru_utime.tv_usec + r.ru_stime.tv_usec);
utils.cpp:	return tp.tv_sec + tp.tv_usec * 1e-6;
kthread.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
kthread.h:// ----------------
kthread.h:// -------------------
kthread.h:// ---------------
kthread.h:// ---------------
Binary file profiling.o matches
macro.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
macro.h:/* Note: BSW-specific macros are in src/bandedSWA.h file */
macro.h:#define H0_ -99
kseq.h:#define ks_eof(ks) ((ks)->is_eof && (ks)->begin >= (ks)->end)
kseq.h:#define ks_rewind(ks) ((ks)->is_eof = (ks)->begin = (ks)->end = 0)   
kseq.h:		ks->f = f;													\
kseq.h:		ks->buf = (unsigned char*)malloc(__bufsize);				\
kseq.h:		ks->enc_buf.resize(__bufsize);								\
kseq.h:		/*ks->enc_buf.shrink_to_fit();		*/						\
kseq.h:		printf("ks->enc_buf.size(): %d\n",ks->enc_buf.size());							\
kseq.h:        assert(ks->buf != NULL);                                    \
kseq.h:		assert(ks->enc_buf.size()!=0);								\
kseq.h:			free(ks->buf);											\
kseq.h:			ks->enc_buf.clear();									\
kseq.h:			ks->enc_buf.shrink_to_fit();							\
kseq.h:		/* printf("Entered ks_getc, ks->begin: %d, ks->end: %d, ks->is_eof: %d\n", ks->begin, ks->end, ks->is_eof);		*/					\
kseq.h:		if (ks->is_eof && ks->begin >= ks->end) return encrypt_plaintext_integer_to_ciphertext(-1);	\
kseq.h:		if (ks->begin >= ks->end) {							\
kseq.h:			ks->begin = 0;									\
kseq.h:			printf("1 Reading into ks->buf via __read()\n");		\
kseq.h:			ks->end = __read(ks->f, ks->buf, __bufsize);	\
kseq.h:			if (ks->end == 0) { ks->is_eof = 1; 			\
kseq.h:			return encrypt_plaintext_integer_to_ciphertext(-1);}	\
kseq.h:			/* ks->enc_buf.clear();				*/			\
kseq.h:			printf("Assigning from ks->buf to ks->enc_buf; ks->end: %d\n",ks->end);	\
kseq.h:			printf("&ks->enc_buf[0]: %x\n",&ks->enc_buf[0]);	\
kseq.h:			for(int i=0; i<ks->end; i++)					\
kseq.h:				int c = (int)(ks->buf[i]);					\
kseq.h:				printf("time for one byte encryption: %lf\n",double(c_end - c_begin) / CLOCKS_PER_SEC);			*/								\
kseq.h:				ks->enc_buf[i] = ciphertext;				\
kseq.h:			printf("Assigned!; sizeof(kstream ks->buf): %lu; sizeof(kstream ks->buf)/sizeof(ks->buf[0]): %lu\n",sizeof(ks->buf),sizeof(ks->buf)/sizeof(ks->buf[0]));						\
kseq.h:			double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;							\
kseq.h:			/* printf("ks->end: %d\n",ks->end);		*/		\
kseq.h:		/* return (int)ks->buf[ks->begin++];*/				\
kseq.h:		/* cout<<"ks_getc is returning: \n"; /*<<ks->enc_buf[ks->begin++]<<endl;*/	\
kseq.h:		/* printf("Leaving ks_getc, ks->begin: %d, ks->end: %d, ks->is_eof: %d\n", ks->begin, ks->end, ks->is_eof);				*/			\
kseq.h:		return ks->enc_buf[ks->begin++];					\
kseq.h:#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
kseq.h:/*str->l = (i-ks->begin) is returned in case of comment; 1+(i-ks->begin) returned in main case; so str->l is total size of chars copied*/
kseq.h:		/* printf("At start, ks->begin: %d, ks->end: %d\n",ks->begin,ks->end);		*/			\
kseq.h:		str->l = append? str->l : 0;									\
kseq.h:			if (ks->begin >= ks->end) {									\
kseq.h:				if (!ks->is_eof) {										\
kseq.h:					ks->begin = 0;										\
kseq.h:					printf("2 Reading into ks->buf via __read()\n");		\
kseq.h:					ks->end = __read(ks->f, ks->buf, __bufsize);		\
kseq.h:					/* ks->enc_buf.clear();		*/						\
kseq.h:					printf("Assigning from ks->buf to ks->enc_buf ; ks->end: %d\n",ks->end);	\
kseq.h:					printf("&ks->enc_buf[0]: %x\n",&ks->enc_buf[0]);	\
kseq.h:					for(int h=0; h<ks->end; h++)						\
kseq.h:						c = (int)(ks->buf[h]);						\
kseq.h:						/* printf("original ks->enc_buf[h]: %c\n",decrypt_ciphertext_to_plaintext_vector(ks->enc_buf[h])[0]);	*/	\
kseq.h:						printf("time for one byte encryption: %lf\n",double(c_end - c_begin) / CLOCKS_PER_SEC);				*/							\
kseq.h:						ks->enc_buf[h]= c_ct;				\
kseq.h:					printf("Assigned!; sizeof(kstream ks->buf): %lu; sizeof(kstream ks->buf)/sizeof(kstream ks->buf[0]): %lu\n",sizeof(ks->buf),sizeof(ks->buf)/sizeof(ks->buf[0]));			\
kseq.h:					elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;							\
kseq.h:					if (ks->end == 0) { ks->is_eof = 1; break; }		\
kseq.h:					/* printf("Read new chars into ks->buf; now ks->begin: %d, ks->end: %d\n",ks->begin,ks->end);*/			\
kseq.h:				for (i = ks->begin; i < ks->end; ++i) \
kseq.h:					if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\n')))[0]==0) break; \
kseq.h:				for (i = ks->begin; i < ks->end; ++i)					\
kseq.h:					if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext(delimiter)))[0]==0) break;					\
kseq.h:				for (i = ks->begin; i < ks->end; ++i)					\
kseq.h:					if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\n')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext(' ')))[0]==0 ||	\
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\f')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\r')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\t')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\v')))[0]==0)	\
kseq.h:				for (i = ks->begin; i < ks->end; ++i)					\
kseq.h:					if( (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\n')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext(' ')))[0]==0 ||	\
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\f')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\r')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\t')))[0]==0 || \
kseq.h:					decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext('\v')))[0]==0) && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(ks->enc_buf[i], encode_integer_to_plaintext(' ')))[0]!=0) break; \
kseq.h:			/*printf("i: %d\n",i);		/*i is index of \n in ks->buf in case of KS_SEP_LINE*/	\
kseq.h:			/* Below runs if ks->buf[i]==delimiter (like \n) is 'not' encountered in the string read into ks->buf from file */	\
kseq.h:			/* printf("Earlier, str->m: %d, str->l: %d, i: %d, ks->begin: %d, str->enc_s.size(): %d\n",str->m,str->l,i,ks->begin,str->enc_s.size());	*/						\
kseq.h:			if (str->m - str->l < (size_t)(i - ks->begin + 1)) {		\
kseq.h:				str->m = str->l + (i - ks->begin) + 1;					\
kseq.h:				kroundup32(str->m);										\
kseq.h:				/* str->s = (char*)calloc(str->m,sizeof(char));	*/		\
kseq.h:				str->enc_s.resize(str->m);									\
kseq.h:			/* memcpy_bwamem(str->s + str->l, str->m - str->l, ks->buf + ks->begin, i - ks->begin, __FILE__, __LINE__); */ \
kseq.h:			memcpy_bwamem_enc(&str->enc_s, str->l, str->m - str->l, &ks->enc_buf, ks->begin, i - ks->begin, __FILE__, __LINE__); \
kseq.h:			/* vector<CT> vv(str->enc_s.begin()+str->l,str->enc_s.end());		\
kseq.h:			strcpy(str->s+str->l,enc_s_string);							*/	\
kseq.h:			/* (i-ks->begin) bytes are copied from (ks->buf+ks->begin) to (str->s+str->l); str->m-str->l = ks->end-ks->begin+1 */	\
kseq.h:			/* printf("After memcpy_bwamem, str->s+str->l: %s, str->l: %d, str->m: %d\n",str->s+str->l,str->l,str->m);	*/\
kseq.h:			str->l = str->l + (i - ks->begin);							\
kseq.h:			ks->begin = i + 1;											\
kseq.h:			/* printf("neww str->l: %d, ks->begin=i+1= %d\n",str->l,ks->begin);		*/	\
kseq.h:			/* If i==ks->end, then while reading from ks->buf, ks->begin reached ks->end, so, i=ks->begin=ks->end now. But we are yet to read the delimiter. */	\
kseq.h:			/*If before memcpy_bwamem, ks->begin: 16319, ks->end: 16384, */	\
kseq.h:			if (i < ks->end) {											\
kseq.h:				/*ks->buf[i] is DELIMITER*/								\
kseq.h:				/* printf("i: %d, ks->end: %d\n",i,ks->end);	*/			\
kseq.h:				/* printf("decrypt_ciphertext_to_plaintext_vector(ks->enc_buf[i])[0]: %c\n",(char)(decrypt_ciphertext_to_plaintext_vector(ks->enc_buf[i])[0]));	 */	\
kseq.h:				if (dret) *dret = ks->enc_buf[i];						\
kseq.h:		if (!gotany && ks_eof(ks)) return -1;							\
kseq.h:		/* printf("str->s+str->l: %s, str->l: %d, str->m: %d\n",str->s+str->l,str->l,str->m);			\
kseq.h:		printf("str->enc_s.size(): %d\n",str->enc_s.size());				\
kseq.h:		vector<CT> vv(str->enc_s.begin()+str->l,str->enc_s.end());		\
kseq.h:		if ((str->enc_s).size() == 0) {												\
kseq.h:			str->m = 1;													\
kseq.h:			/* str->s = (char*)calloc(1, 1);	*/						\
kseq.h:			(str->enc_s).resize(1);											\
kseq.h:			/* (str->enc_s).shrink_to_fit();	*/							\
kseq.h:            /* assert(str->s != NULL);    */                                 \
kseq.h:			assert((str->enc_s).size()!=0);									\
kseq.h:		} else if (delimiter == KS_SEP_LINE && str->l > 1 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(str->enc_s[str->l-1] , encode_integer_to_plaintext('\r')))[0]==0) --str->l; \
kseq.h:		/* str->s[str->l] = '\0';		*/								\
kseq.h:		str->enc_s[str->l]=encrypt_plaintext_integer_to_ciphertext('\0');			\
kseq.h:		/* printf("At end, ks->begin: %d, str->l: %d\n\n",ks->begin,str->l); 	*/ \
kseq.h:		return str->l;													\
kseq.h:#define kseq_rewind(ks)  ((ks)->f->is_eof = (ks)->f->begin = (ks)->f->end = 0; (ks)->last_char = 0; (ks)->last_char = encrypt_plaintext_integer_to_ciphertext(0);) 
kseq.h:		/* s->last_char = 0;		*/	\
kseq.h:		s->last_char = encrypt_plaintext_integer_to_ciphertext(0);		\
kseq.h:		s->f = ks_init(fd);												\
kseq.h:		free(ks->name.s); free(ks->comment.s); free(ks->seq.s);	free(ks->qual.s);   \
kseq.h:		(ks->name.enc_s).clear(); (ks->comment.enc_s).clear(); (ks->seq.enc_s).clear(); (ks->qual.enc_s).clear(); 	\
kseq.h:		(ks->name.enc_s).shrink_to_fit(); (ks->comment.enc_s).shrink_to_fit(); (ks->seq.enc_s).shrink_to_fit(); (ks->qual.enc_s).shrink_to_fit(); \
kseq.h:		ks_destroy(ks->f);												\
kseq.h:   -1   end-of-file
kseq.h:   -2   truncated quality string
kseq.h:/* ks_getc() returns ks->enc_buf[ks->begin++] */
kseq.h:		kstream_t *ks = seq->f; \
kseq.h:		if (compare_enc(seq->last_char,0)) { /* then jump to the next header line */ \
kseq.h:			while(!compare_enc((c = ks_getc(ks)),-1) && !compare_enc(c,'>') && !compare_enc(c,'@'));		\
kseq.h:			if (compare_enc(c,-1)) return -1; /* end of file */ \
kseq.h:			int cmp_ret=(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext(-1)))[0]!=0);				\
kseq.h:			double cmp_elapsed_secs = double(cmp_end - cmp_begin) / CLOCKS_PER_SEC;							\
kseq.h:			/* cc->EvalMult(c, c2);		*/		\
kseq.h:			/* double mul_elapsed_secs = double(mul_end - mul_begin) / CLOCKS_PER_SEC;							\
kseq.h:			seq->last_char = c; \
kseq.h:			/* printf("decrypt_ciphertext_to_plaintext_vector(seq->last_char)[0]: %c\n",decrypt_ciphertext_to_plaintext_vector(seq->last_char)[0]);	*/	\
kseq.h:			/* seq->last_char=decrypt_ciphertext_to_plaintext_vector(c)[0];	*/	\
kseq.h:		seq->comment.l = seq->seq.l = seq->qual.l = 0; /* reset all members */ \
kseq.h:		if (ks_getuntil(ks, 0, &seq->name, &c) < 0) return -1; /*0 here means read till space; normal exit: EOF */ \
kseq.h:		printf("convert_ciphertext_vector_to_plaintext_string(seq->name.enc_s): %s\n",convert_ciphertext_vector_to_plaintext_string(seq->name.enc_s)); \
kseq.h:			ks_getuntil(ks, KS_SEP_LINE, &seq->comment, 0); /* read FASTA/Q comment */ \
kseq.h:			/*printf("seq->comment.s: %s\n",seq->comment.s);*/	\
kseq.h:			vecInt comment=convert_ciphertext_vector_to_plaintext_vector(seq->comment.enc_s);	\
kseq.h:		if ((seq->seq.enc_s).size()==0) { /* we can do this in the loop below, but that is slower */ \
kseq.h:			seq->seq.m = 256; \
kseq.h:			/* seq->seq.s = (char*)malloc(seq->seq.m);*/ /* seq.m is the total space for seq.s, and seq.l is current position of character read */ \
kseq.h:			seq->seq.enc_s=v;									\
kseq.h:            assert((seq->seq.enc_s).size()!=0);             \
kseq.h:		while (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub((c = ks_getc(ks)), encode_integer_to_plaintext(-1)))[0]!=0 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('>')))[0]!=0 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('+')))[0]!=0 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('@')))[0]!=0) { \
kseq.h:			if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('\n')))[0]==0) continue; /* skip empty lines */ \
kseq.h:			seq->seq.enc_s[seq->seq.l++] = c; /* this is safe: we always have enough space for 1 char */ \
kseq.h:			ks_getuntil2(ks, KS_SEP_LINE, &seq->seq, 0, 1); /* read the rest of the line */ \
kseq.h:			/* printf("seq->seq.s: %s\n",seq->seq.s); */\
kseq.h:			printf("convert_ciphertext_vector_to_plaintext_string(seq->seq.enc_s): %s\n",convert_ciphertext_vector_to_plaintext_string(seq->seq.enc_s)); \
kseq.h:		if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('>')))[0]==0 || decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('@')))[0]==0) {	\
kseq.h:			/* seq->last_char = decrypt_ciphertext_to_plaintext_vector(c)[0]; /* the first header char has been read */	\
kseq.h:			seq->last_char=c;	}\
kseq.h:		if (seq->seq.l + 1 >= seq->seq.m) { /* seq->seq.s[seq->seq.l] below may be out of boundary */ \
kseq.h:			seq->seq.m = seq->seq.l + 16;								\
kseq.h:			kroundup32(seq->seq.m); /* rounded to the next closest 2^k */ \
kseq.h:			(seq->seq.enc_s).resize(seq->seq.m);			\
kseq.h:			/* seq->seq.s = (char*)calloc(seq->seq.m,sizeof(char));	*/	\
kseq.h:            assert((seq->seq.enc_s).size()!=0);					\
kseq.h:		seq->seq.enc_s[seq->seq.l] = encrypt_plaintext_integer_to_ciphertext(0);	/* null terminated string */ \
kseq.h:		if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('+')))[0]!=0) return seq->seq.l; /* FASTA */ \
kseq.h:		if (seq->qual.m < seq->seq.m) {	/* allocate memory for qual in case insufficient */ \
kseq.h:			seq->qual.m = seq->seq.m; \
kseq.h:			/* seq->qual.s = (char*)calloc(seq->qual.m,sizeof(char)); */ \
kseq.h:			(seq->qual.enc_s).resize(seq->qual.m);				\
kseq.h:		while (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub((c = ks_getc(ks)), encode_integer_to_plaintext(-1)))[0]!=0 && decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext('\n')))[0]!=0); /* skip the rest of '+' line */ \
kseq.h:		if (decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(c, encode_integer_to_plaintext(-1)))[0]==0) return -2; /* error: no quality string */ \
kseq.h:		while (ks_getuntil2(ks, KS_SEP_LINE, &seq->qual, 0 , 1) >= 0 && seq->qual.l < seq->seq.l); \
kseq.h:		printf("convert_ciphertext_vector_to_plaintext_string(seq->qual.enc_s): %s\n",convert_ciphertext_vector_to_plaintext_string(seq->qual.enc_s)); \
kseq.h:		/* seq->last_char=0;		*/	\
kseq.h:		seq->last_char = encrypt_plaintext_integer_to_ciphertext(0);	/* we have not come to the next header line */ \
kseq.h:		/* printf("seq->name.l: %d, seq->comment.l: %d, seq->seq.l: %d, seq->qual.l: %d\n\n",seq->name.l,seq->comment.l,seq->seq.l,seq->qual.l); */		\
kseq.h:		cout<<"seq->last_char: "<<decrypt_ciphertext_to_plaintext_vector(seq->last_char)[0]<<"; seq->seq.l: "<<seq->seq.l<<"; seq->qual.l: "<<seq->qual.l<<endl;		\
kseq.h:		if (seq->seq.l != seq->qual.l) return -2; /* error: qual string is of a different length */ \
kseq.h:		return seq->seq.l; \
Binary file kstring.o matches
Binary file bwamem.o matches
Binary file kthread.o matches
kopen.cpp:	if (ret == -1) perror("select");
kopen.cpp:#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)
kopen.cpp:#define __err_connect2(func) do { perror(func); freeaddrinfo(res); close(fd); return -1; } while (0)
kopen.cpp:	if ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect("socket");
kopen.cpp:	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect2("setsockopt");
kopen.cpp:	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect2("setsockopt");
kopen.cpp:	if (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect2("connect");
kopen.cpp:			len -= bytes;
kopen.cpp:			return -1;
kopen.cpp:	// set ->http_host
kopen.cpp:	l = p - fn - 7;
kopen.cpp:		fd = -1;
kopen.cpp:			if (strncmp(buf + l - 3, "\r\n\r\n", 4) == 0) break;
kopen.cpp:		fd = -1;
kopen.cpp:		fd = -1;
kopen.cpp:	if (socket_wait(aux->ctrl_fd, 1) <= 0) return 0;
kopen.cpp:	while (read(aux->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O
kopen.cpp:		if (n >= aux->max_response) {
kopen.cpp:			aux->max_response = aux->max_response? aux->max_response<<1 : 256;
kopen.cpp:			aux->response = (char*) realloc(aux->response, aux->max_response);
kopen.cpp:		aux->response[n++] = c;
kopen.cpp:			if (n >= 4 && isdigit(aux->response[0]) && isdigit(aux->response[1]) && isdigit(aux->response[2])
kopen.cpp:				&& aux->response[3] != '-') break;
kopen.cpp:	if (n < 2) return -1;
kopen.cpp:	aux->response[n-2] = 0;
kopen.cpp:	return strtol(aux->response, &p, 0);
kopen.cpp:	if (socket_wait(aux->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing
kopen.cpp:	if (write_bytes(aux->ctrl_fd, cmd, strlen(cmd)) != 0) return -1;
kopen.cpp:	int v[6], l, fd = -1, ret, pasv_port, pasv_ip[4];
kopen.cpp:	l = p - fn - 6;
kopen.cpp:	if (aux.ctrl_fd == -1) goto ftp_open_end; /* fail to connect ctrl */
kopen.cpp:	if (fd == -1) goto ftp_open_end;
kopen.cpp:		fd = -1;
kopen.cpp:	for (i = end - 1; i >= 0; --i)
kopen.cpp:		if (isspace(cmd[i]) && !isspace(cmd[i-1]))
kopen.cpp:	argv[0] = str = (char*)calloc(end - beg + 1, 1);
kopen.cpp:	strncpy_s(argv[0], end - beg + 1, cmd + beg, end - beg);
kopen.cpp:	for (i = argc = 1; i < end - beg; ++i)
kopen.cpp:		else if (str[i] && str[i-1] == 0) argv[argc++] = &str[i];
kopen.cpp:	*_fd = -1;
kopen.cpp:		aux->type = KO_HTTP;
kopen.cpp:		aux->fd = http_open(fn);
kopen.cpp:		aux->type = KO_FTP;
kopen.cpp:		aux->fd = ftp_open(fn);
kopen.cpp:	} else if (strcmp(fn, "-") == 0) {
kopen.cpp:		aux->type = KO_STDIN;
kopen.cpp:		aux->fd = STDIN_FILENO;
kopen.cpp:				if (ispunct(*q) && *q != '.' && *q != '_' && *q != '-' && *q != ':')
kopen.cpp:			if (pid == -1) { /* vfork() error */
kopen.cpp:				} else execl("/bin/sh", "sh", "-c", p + 1, NULL);
kopen.cpp:				aux->type = KO_PIPE;
kopen.cpp:				aux->fd = pfd[0];
kopen.cpp:				aux->pid = pid;
kopen.cpp:				aux->type = KO_FILE;
kopen.cpp:				aux->fd = *_fd;
kopen.cpp:	if (aux) *_fd = aux->fd;
kopen.cpp:	if (aux->type == KO_PIPE) {
kopen.cpp:		pid = waitpid(aux->pid, &status, WNOHANG);
kopen.cpp:		if (pid != aux->pid) kill(aux->pid, 15);
Binary file bwamem_pair.o matches
Binary file bntseq.o matches
read_index_ele.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
read_index_ele.cpp:    if (idx->mem == 0)
read_index_ele.cpp:        if (idx->bns) bns_destroy(idx->bns);
read_index_ele.cpp:        if (idx->pac) free(idx->pac);
read_index_ele.cpp:        free(idx->bns->anns); free(idx->bns);
read_index_ele.cpp:        if (!idx->is_shm) free(idx->mem);
read_index_ele.cpp:    // int l_hint=hint.size()-1;
read_index_ele.cpp:    assign_string_to_vecCT(prefix,hh,-1);
read_index_ele.cpp:    fprintf(stderr, "* Index prefix: %s\n", convert_ciphertext_vector_to_plaintext_string(prefix));    // Index prefix: ../../input-datasets/fmi/broad
read_index_ele.cpp:        idx->bns = bns_restore(convert_ciphertext_vector_to_plaintext_string(prefix));
read_index_ele.cpp:        if (idx->bns == 0) {
read_index_ele.cpp:        for (i = c = 0; operate_and_decrypt(idx->bns->n_seqs_enc,"-",i)>0; ++i)
read_index_ele.cpp:            if (idx->bns->anns[i].is_alt) ++c;
read_index_ele.cpp:            idx->pac = (uint8_t*) calloc(idx->bns->l_pac/4+1, 1); idx->pac_enc.resize(idx->bns->l_pac/4+1);
read_index_ele.cpp:            assert(idx->pac != NULL);
read_index_ele.cpp:            err_fread_noeof(idx->pac, 1, idx->bns->l_pac/4+1, idx->bns->fp_pac); // concatenated 2-bit encoded sequence
read_index_ele.cpp:            err_fclose(idx->bns->fp_pac);
read_index_ele.cpp:            for(int h=0;h<idx->bns->l_pac/4+1; h++)
read_index_ele.cpp:                idx->pac_enc[h]=encrypt_plaintext_integer_to_ciphertext(idx->pac[h]);
read_index_ele.cpp:            idx->bns->fp_pac = 0;
read_index_ele.cpp://  bwaEle->bwa_idx_load_ele("/projects/PCL-GBB/wasim/read_and_ref_data_1/hgaa.fa",
kbtree.h:/*-
kbtree.h: * Copyright 1997-1999, 2001, John-Mark Gurney.
kbtree.h: *           2008-2009, Attractive Chaos <attractor@live.co.uk>
kbtree.h:#define __KB_PTR(btr, x)	((kbnode_t**)((char*)x + btr->off_ptr))
kbtree.h:		b->t = ((size - 4 - sizeof(void*)) / (sizeof(void*) + sizeof(key_t)) + 1) >> 1; \
kbtree.h:		if (b->t < 2) {													\
kbtree.h:		b->n = 2 * b->t - 1;											\
kbtree.h:		b->off_ptr = 4 + b->n * sizeof(key_t);							\
kbtree.h:		b->ilen = (4 + sizeof(void*) + b->n * (sizeof(void*) + sizeof(key_t)) + 3) >> 2 << 2; \
kbtree.h:		b->elen = (b->off_ptr + 3) >> 2 << 2;							\
kbtree.h:		b->root = (kbnode_t*)calloc(1, b->ilen);						\
kbtree.h:        assert(b->root != NULL);                                        \
kbtree.h:		++b->n_nodes;													\
kbtree.h:			*top++ = (b)->root;											\
kbtree.h:				x = *--top;												\
kbtree.h:				if (x == 0 || x->is_internal == 0) { free(x); continue; } \
kbtree.h:				for (i = 0; i <= x->n; ++i)								\
kbtree.h:						if (top - stack == max) {						\
kbtree.h:		kbnode_t *__x = (b)->root;			\
kbtree.h:		int tr, *rr, begin, end, n = x->n >> 1;							\
kbtree.h:		if (x->n == 0) return -1;										\
kbtree.h:		} else { begin = n; end = x->n - 1; }							\
kbtree.h:		while (n >= begin && (*rr = __cmp(*k, __KB_KEY(key_t, x)[n])) < 0) --n; \
kbtree.h:		int tr, *rr, begin = 0, end = x->n;								\
kbtree.h:		if (x->n == 0) return -1;										\
kbtree.h:		if (begin == x->n) { *rr = 1; return x->n - 1; }				\
kbtree.h:		if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;	\
kbtree.h:		kbnode_t *x = b->root;											\
kbtree.h:			if (x->is_internal == 0) return 0;							\
kbtree.h:		kbnode_t *x = b->root;											\
kbtree.h:			if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];		\
kbtree.h:			if (x->is_internal == 0) return;							\
kbtree.h:		z = (kbnode_t*)calloc(1, y->is_internal? b->ilen : b->elen);	\
kbtree.h:		++b->n_nodes;													\
kbtree.h:		z->is_internal = y->is_internal;								\
kbtree.h:		z->n = b->t - 1;												\
kbtree.h:		memcpy(__KB_KEY(key_t, z), __KB_KEY(key_t, y) + b->t, sizeof(key_t) * (b->t - 1)); \
kbtree.h:		if (y->is_internal) memcpy(__KB_PTR(b, z), __KB_PTR(b, y) + b->t, sizeof(void*) * b->t); \
kbtree.h:		y->n = b->t - 1;												\
kbtree.h:		memmove(__KB_PTR(b, x) + i + 2, __KB_PTR(b, x) + i + 1, sizeof(void*) * (x->n - i)); \
kbtree.h:		memmove(__KB_KEY(key_t, x) + i + 1, __KB_KEY(key_t, x) + i, sizeof(key_t) * (x->n - i)); \
kbtree.h:		__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[b->t - 1];			\
kbtree.h:		++x->n;															\
kbtree.h:		int i = x->n - 1;												\
kbtree.h:		if (x->is_internal == 0) {										\
kbtree.h:			if (i != x->n - 1)											\
kbtree.h:				memmove(__KB_KEY(key_t, x) + i + 2, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \
kbtree.h:			++x->n;														\
kbtree.h:			if (__KB_PTR(b, x)[i]->n == 2 * b->t - 1) {					\
kbtree.h:		++b->n_keys;													\
kbtree.h:		r = b->root;													\
kbtree.h:		if (r->n == 2 * b->t - 1) {										\
kbtree.h:			++b->n_nodes;												\
kbtree.h:			s = (kbnode_t*)calloc(1, b->ilen);							\
kbtree.h:			b->root = s; s->is_internal = 1; s->n = 0;					\
kbtree.h:			r = x->is_internal == 0? 0 : s == 1? 1 : -1;				\
kbtree.h:			i = s == 1? x->n - 1 : -1;									\
kbtree.h:		if (x->is_internal == 0) {										\
kbtree.h:			memmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \
kbtree.h:			--x->n;														\
kbtree.h:			if ((yn = __KB_PTR(b, x)[i]->n) >= b->t) {					\
kbtree.h:			} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= b->t) {		\
kbtree.h:			} else if (yn == b->t - 1 && zn == b->t - 1) {				\
kbtree.h:				__KB_KEY(key_t, y)[y->n++] = *k;						\
kbtree.h:				memmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, z), z->n * sizeof(key_t)); \
kbtree.h:				if (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, z), (z->n + 1) * sizeof(void*)); \
kbtree.h:				y->n += z->n;											\
kbtree.h:				memmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \
kbtree.h:				memmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (x->n - i - 1) * sizeof(void*)); \
kbtree.h:				--x->n;													\
kbtree.h:		if ((xp = __KB_PTR(b, x)[i])->n == b->t - 1) {					\
kbtree.h:			if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= b->t) {		\
kbtree.h:				memmove(__KB_KEY(key_t, xp) + 1, __KB_KEY(key_t, xp), xp->n * sizeof(key_t)); \
kbtree.h:				if (xp->is_internal) memmove(__KB_PTR(b, xp) + 1, __KB_PTR(b, xp), (xp->n + 1) * sizeof(void*)); \
kbtree.h:				__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];		\
kbtree.h:				__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \
kbtree.h:				if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \
kbtree.h:				--y->n; ++xp->n;										\
kbtree.h:			} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= b->t) { \
kbtree.h:				__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];	\
kbtree.h:				if (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \
kbtree.h:				--y->n;													\
kbtree.h:				memmove(__KB_KEY(key_t, y), __KB_KEY(key_t, y) + 1, y->n * sizeof(key_t)); \
kbtree.h:				if (y->is_internal) memmove(__KB_PTR(b, y), __KB_PTR(b, y) + 1, (y->n + 1) * sizeof(void*)); \
kbtree.h:			} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == b->t - 1) { \
kbtree.h:				__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];	\
kbtree.h:				memmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, xp), xp->n * sizeof(key_t));	\
kbtree.h:				if (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, xp), (xp->n + 1) * sizeof(void*)); \
kbtree.h:				y->n += xp->n;											\
kbtree.h:				memmove(__KB_KEY(key_t, x) + i - 1, __KB_KEY(key_t, x) + i, (x->n - i) * sizeof(key_t)); \
kbtree.h:				memmove(__KB_PTR(b, x) + i, __KB_PTR(b, x) + i + 1, (x->n - i) * sizeof(void*)); \
kbtree.h:				--x->n;													\
kbtree.h:			} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == b->t - 1) { \
kbtree.h:				__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];	\
kbtree.h:				memmove(__KB_KEY(key_t, xp) + xp->n, __KB_KEY(key_t, y), y->n * sizeof(key_t));	\
kbtree.h:				if (xp->is_internal) memmove(__KB_PTR(b, xp) + xp->n, __KB_PTR(b, y), (y->n + 1) * sizeof(void*)); \
kbtree.h:				xp->n += y->n;											\
kbtree.h:				memmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \
kbtree.h:				memmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (x->n - i - 1) * sizeof(void*)); \
kbtree.h:				--x->n;													\
kbtree.h:		ret = __kb_delp_aux_##name(b, b->root, k, 0);					\
kbtree.h:		--b->n_keys;													\
kbtree.h:		if (b->root->n == 0 && b->root->is_internal) {					\
kbtree.h:			--b->n_nodes;												\
kbtree.h:			x = b->root;												\
kbtree.h:			b->root = __KB_PTR(b, x)[0];								\
kbtree.h:		__kp->x = (b)->root; __kp->i = 0;								\
kbtree.h:			while (__kp->x && __kp->i <= __kp->x->n) {					\
kbtree.h:				if (__kp - __kstack == __kmax - 1) {					\
kbtree.h:					__kp = __kstack + (__kmax>>1) - 1;					\
kbtree.h:				(__kp+1)->i = 0; (__kp+1)->x = __kp->x->is_internal? __KB_PTR(b, __kp->x)[__kp->i] : 0; \
kbtree.h:			--__kp;														\
kbtree.h:				if (__kp->x && __kp->i < __kp->x->n) __func(&__KB_KEY(key_t, __kp->x)[__kp->i]); \
kbtree.h:				++__kp->i;												\
kbtree.h:#define kb_size(b) ((b)->n_keys)
kbtree.h:#define kb_generic_cmp(a, b) (((b) < (a)) - ((a) < (b)))
bntseq.h:	return (*is_rev = (pos >= bns->l_pac))? (bns->l_pac<<1) - 1 - pos : pos;
bwt.h:#define OCC_INTV_MASK  (OCC_INTERVAL - 1)
bwt.h:	bwtint_t primary; // S^{-1}(0), or the primary index of BWT
bwt.h:#define bwt_bwt(b, k) ((b)->bwt[(k)/OCC_INTERVAL * (OCC_INTERVAL/(sizeof(uint32_t)*8/2) + sizeof(bwtint_t)/4*4) + sizeof(bwtint_t)/4*4 + (k)%OCC_INTERVAL/16])
bwt.h:#define bwt_occ_intv(b, k) ((b)->bwt + (k)/OCC_INTERVAL * (OCC_INTERVAL/(sizeof(uint32_t)*8/2) + sizeof(bwtint_t)/4*4)
bwt.h:#define bwt_bwt(b, k) ((b)->bwt[((k)>>7<<4) + sizeof(bwtint_t) + (((k)&0x7f)>>4)])
bwt.h:#define bwt_occ_intv(b, k) ((b)->bwt + ((k)>>7<<4))
bwt.h:/* retrieve a character from the $-removed BWT string. Note that
bwt.h:#define bwt_set_intv(bwt, c, ik) ((ik).x[0] = (bwt)->L2[(int)(c)]+1, (ik).x[2] = (bwt)->L2[(int)(c)+1]-(bwt)->L2[(int)(c)], (ik).x[1] = (bwt)->L2[3-(c)]+1, (ik).info = 0)
bwt.h:    void bwt_bwtgen(const char *fn_pac, const char *fn_bwt); // from BWT-SW
bwt.h:    void bwt_bwtgen2(const char *fn_pac, const char *fn_bwt, int block_size); // from BWT-SW
bwt.h: * Extend bi-SA-interval _ik_
Binary file FMI_search.o matches
FMI_search.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
FMI_search.cpp:    // map<pair<int,int>,pair<pair<int,int>,pair<int,int> > > cp_occ_cp_count_map;        //For cp_occ[i].cp_count[j]-  ((i,j),((ciphertext_1_no,index_in_ciphertext_1),(ciphertext_2_no,index_in_ciphertext_2)))
FMI_search.cpp:	err_fseek(fp, -1, SEEK_END);
FMI_search.cpp:	return (pac_len - 1) * 4 + (int)c;
FMI_search.cpp:		int nt = buf2[i>>2] >> ((3 - (i&3)) << 1) & 3;
FMI_search.cpp:    for(i = seq_len - 1; i >= 0; i--)
FMI_search.cpp:    int64_t ref_seq_len_aligned = ((ref_seq_len + CP_BLOCK_SIZE - 1) / CP_BLOCK_SIZE) * CP_BLOCK_SIZE;
FMI_search.cpp:    int64_t sentinel_index = -1;
FMI_search.cpp:            char c = binary_seq[sa_bwt[i]-1];
FMI_search.cpp:                    // cpo.one_hot_bwt_str_enc[c] = cc->EvalAdd(cpo.one_hot_bwt_str_enc[c], 1);
FMI_search.cpp:    fprintf(stderr, "init ticks = %llu\n", __rdtsc() - startTick);
FMI_search.cpp:    fprintf(stderr, "binary seq ticks = %llu\n", __rdtsc() - startTick);
FMI_search.cpp:    fprintf(stderr, "build suffix-array ticks = %llu\n", __rdtsc() - startTick);
FMI_search.cpp:    fprintf(stderr, "build fm-index ticks = %llu\n", __rdtsc() - startTick);
FMI_search.cpp:        one_hot_mask_array[i] = (one_hot_mask_array[i - 1] >> 1) | base;
FMI_search.cpp:    // strcat_enc(cp_file_name,CP_FILENAME_SUFFIX,-1);
FMI_search.cpp:    cpstream = fopen(cp_file_name,"rb");                            // cp_file_name is ../input-datasets/fmi/broad.bwt.2bit.64
FMI_search.cpp:    // assert(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(reference_seq_len, encrypt_plaintext_integer_to_ciphertext(0)))[0]>0);
FMI_search.cpp:    // assert(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(reference_seq_len, encrypt_plaintext_integer_to_ciphertext(0x7fffffffffL)))[0]<=0);
FMI_search.cpp:    // fprintf(stderr, "* Reference seq len for bi-index = %ld\n", decrypt_ciphertext_to_plaintext_vector(reference_seq_len)[0]);
FMI_search.cpp:    // CT cp_occ_size_enc = cc->EvalAdd(shift_encrypted_bit_vector_and_return_integer(reference_seq_len_encrypted_bit_vector, CP_SHIFT), encrypt_plaintext_integer_to_ciphertext(1));  //CP_SHIFT=6
FMI_search.cpp:    // decrypt_ciphertext_to_plaintext_vector(reference_seq_len_enc)[0]: -744758
FMI_search.cpp:    fprintf(stderr, "* Reference seq len for bi-index = %ld\n", decrypt_ciphertext_to_plaintext_vector(reference_seq_len_enc)[0]);
FMI_search.cpp:    assert(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(reference_seq_len_enc, encode_integer_to_plaintext(0)))[0]>0);
FMI_search.cpp:    // assert(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(reference_seq_len_enc, encode_integer_to_plaintext(0x7fffffffffL)))[0]<=0);
FMI_search.cpp:    CT cp_occ_size_enc = cc->EvalAdd(shift_encrypted_bit_vector_and_return_integer(reference_seq_len_encrypted_bit_vector, -1*CP_SHIFT), encrypt_plaintext_integer_to_ciphertext(1));  //CP_SHIFT=6
FMI_search.cpp:    fprintf(stderr, "* Reference seq len for bi-index = %ld\n", reference_seq_len);
FMI_search.cpp:    // the following statement requests a 64-byte aligned memory block for 8 floating point elements-  farray = (float *)__mm_malloc(8*sizeof(float), 64);
FMI_search.cpp:    // https://stackoverflow.com/questions/3994035/what-is-aligned-memory-allocation
FMI_search.cpp:    // cp_occ->cp_count_enc.resize(tot_cp_occ_ct_count);
FMI_search.cpp:    // cp_occ->one_hot_bwt_str=(uint64_t*)(calloc(tot_cp_occ_ct_count,sizeof(uint64_t)));
FMI_search.cpp:    //             cout<<"Single- cp_occ_cp_count_ciphertext_count: "<<cp_occ_cp_count_ciphertext_count<<"; cp_occ_cp_count_index: "<<cp_occ_cp_count_index<<endl;
FMI_search.cpp:    //                 zz=(zz-zz%p)/p;
FMI_search.cpp:    //             // as zz was too big, so 2 components of that have been formed and written to vv; note that the above while-loop will run for only 2 iterations
FMI_search.cpp:    //             cout<<"Two times- ct_count1: "<<ct_count1<<"; index1: "<<index1<<"; ct_count2: "<<ct_count2<<"; index2: "<<index2<<endl;
FMI_search.cpp:    //             vv[j]=-1*(p-1);
FMI_search.cpp:    //                 zz=(zz-zz%p)/p;
FMI_search.cpp:    //         // cp_occ->one_hot_bwt_str[j]=cp_occ_read[(i*16384+j)/4].one_hot_bwt_str[(i*16384+j)%4];
FMI_search.cpp:        count_enc[ii]=cc->EvalAdd(count_enc[ii],encode_integer_to_plaintext(1));
FMI_search.cpp:    CT reference_seq_len_enc_ = cc->EvalAdd(shift_encrypted_bit_vector_and_return_integer(reference_seq_len_encrypted_bit_vector, -1*SA_COMPX), encrypt_plaintext_integer_to_ciphertext(1));
FMI_search.cpp:    // while(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(reference_seq_len_enc, encode_integer_to_plaintext(sz)))[0]!=0)
FMI_search.cpp:    // While decrypting, sa_ms_byte, type-cast it to int8_t. For sa_ls_word, type-cast it to uint32_t
FMI_search.cpp:    sentinel_index = -1;
FMI_search.cpp:    sentinel_index_enc = encrypt_plaintext_integer_to_ciphertext(-1);
FMI_search.cpp:    fprintf(stderr, "* sentinel-index: %ld\n", sentinel_index);
FMI_search.cpp:    // fprintf(stderr, "* sentinel-index: %ld\n", sentinel_index);
FMI_search.cpp:    fprintf(stderr, "* sentinel-index-enc: %ld\n", decrypt_ciphertext_to_plaintext_vector(sentinel_index_enc)[0]);
FMI_search.cpp:        if(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(get_sa_entry_compressed(x), encode_integer_to_plaintext(0)))[0]==0) {
FMI_search.cpp:        if(decrypt_ciphertext_to_plaintext_vector(cc->EvalSub(get_sa_entry(x), encode_integer_to_plaintext(0)))[0]==0) {
FMI_search.cpp:    fprintf(stderr, "* sentinel-index-enc: %ld\n", decrypt_ciphertext_to_plaintext_vector(sentinel_index_enc)[0]);   
FMI_search.cpp:    // ref_file_name is  ../../input-datasets/fmi/broad
FMI_search.cpp:            smem.l = count[3 - a];
FMI_search.cpp:            smem.s = count[a+1] - count[a];
FMI_search.cpp:                    SMEM newSmem_ = backwardExt(smem_, 3 - a);
FMI_search.cpp:                    //SMEM newSmem_ = forwardExt(smem_, 3 - a);
FMI_search.cpp:                prev[p] = prev[numPrev - p - 1];
FMI_search.cpp:                prev[numPrev - p - 1] = temp;
FMI_search.cpp:            for(j = x - 1; j >= 0; j--)
FMI_search.cpp:                int curr_s = -1;
FMI_search.cpp:                    if((newSmem.s < min_intv_array[i]) && ((smem.n - smem.m + 1) >= minSeedLen))
FMI_search.cpp:                if(((smem.n - smem.m + 1) >= minSeedLen))
FMI_search.cpp:                smem.l = count[3 - a];
FMI_search.cpp:                smem.s = count[a+1] - count[a];
FMI_search.cpp:                        SMEM newSmem_ = backwardExt(smem_, 3 - a);
FMI_search.cpp:                        //SMEM smem = backwardExt(smem, 3 - a);
FMI_search.cpp:                        if((smem.s < max_intv_array[i]) && ((smem.n - smem.m + 1) >= minSeedLen))
FMI_search.cpp:        int32_t perThreadQuota = (numReads + (nthreads - 1)) / nthreads;
FMI_search.cpp:            int x = readlength - 1;
FMI_search.cpp:                    x--;
FMI_search.cpp:                smem.l = count[3 - a];
FMI_search.cpp:                smem.s = count[a+1] - count[a];
FMI_search.cpp:                        SMEM newSmem_ = backwardExt(smem_, 3 - a);
FMI_search.cpp:                    prev[p] = prev[numPrev - p - 1];
FMI_search.cpp:                    prev[numPrev - p - 1] = temp;
FMI_search.cpp:                int next_x = x - 1;
FMI_search.cpp:                for(j = x - 1; j >= 0; j--)
FMI_search.cpp:                    int curr_s = -1;
FMI_search.cpp:                        next_x = j - 1;
FMI_search.cpp:                                if((smem.n - smem.m + 1) >= minSeedLen)
FMI_search.cpp:                        next_x = j - 1;
FMI_search.cpp:                    if((smem.n - smem.m + 1) >= minSeedLen)
FMI_search.cpp:    if(pa->rid < pb->rid)
FMI_search.cpp:        return -1;
FMI_search.cpp:    if(pa->rid > pb->rid)
FMI_search.cpp:    if(pa->m < pb->m)
FMI_search.cpp:        return -1;
FMI_search.cpp:    if(pa->m > pb->m)
FMI_search.cpp:    if(pa->n > pb->n)
FMI_search.cpp:        return -1;
FMI_search.cpp:    if(pa->n < pb->n)
FMI_search.cpp:    int32_t perThreadQuota = (numReads + (nthreads - 1)) / nthreads;
FMI_search.cpp:        s[b] = occ_ep - occ_sp;
FMI_search.cpp:    // sa_entry_enc = cc->EvalAdd(sa_entry_enc,sa_ls_word_enc[pos]); 
FMI_search.cpp://         sa_entry_enc = cc->EvalAdd(sa_entry_enc,sa_ls_word_enc[pos >> SA_COMPX]);
FMI_search.cpp://         sa_entry_enc = cc->EvalAdd(sa_entry_enc,sa_ls_word_enc[pos]);
FMI_search.cpp://             int64_t y_pp_ = CP_BLOCK_SIZE - (sp & CP_MASK) - 1; 
FMI_search.cpp://         // assert((reference_seq_len >> SA_COMPX) - 1 >= (sp >> SA_COMPX));
FMI_search.cpp://         sa_entry_enc = cc->EvalAdd(sa_entry_enc, sa_ls_word_enc[sp >> SA_COMPX]);
FMI_search.cpp://         sa_entry_enc = cc->EvalAdd(sa_entry_enc, sa_ls_word_enc[sp]);
FMI_search.cpp://         sa_entry_enc=cc->EvalAdd(sa_entry_enc,encode_integer_to_plaintext(offset));
FMI_search.cpp:            int64_t y_pp_ = CP_BLOCK_SIZE - (sp & CP_MASK) - 1; 
FMI_search.cpp:        // assert((reference_seq_len >> SA_COMPX) - 1 >= (sp >> SA_COMPX));
FMI_search.cpp:        int64_t y_pp_ = CP_BLOCK_SIZE - (sp & CP_MASK) - 1; 
FMI_search.cpp:    int64_t offset[sa_batch_size] = {-1};
FMI_search.cpp:                    offset[k] = -1;
Binary file bwtindex.o matches
main.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
main.cpp:// ----------------------------------
main.cpp:// ----------------------------------
main.cpp:// ----------------------------------
main.cpp:    fprintf(stderr, "Usage: bwa-mem2 <command> <arguments>\n");
main.cpp:    // ---------------------------------    
main.cpp:    proc_freq = __rdtsc() - tim;
main.cpp:    int ret = -1;
main.cpp:         ret = bwa_index(argc-1, argv+1);
main.cpp:         fprintf(stderr, "Total time taken: %0.4lf\n", (__rdtsc() - tim)*1.0/proc_freq);
main.cpp:        fprintf(stderr, "-----------------------------\n");
main.cpp:        fprintf(stderr, "-----------------------------\n");
main.cpp:        ksprintf(&pg, "@PG\tID:bwa-mem2\tPN:bwa-mem2\tVN:%s\tCL:%s", PACKAGE_VERSION, argv[0]);
main.cpp:        ret = main_mem(argc-1, argv+1);
main.cpp:    printf("Time taken measured in program: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC);
kstring.cpp:	l = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);
kstring.cpp:	if (l + 1 > s->m - s->l) {
kstring.cpp:		s->m = s->l + l + 2;
kstring.cpp:		kroundup32(s->m);
kstring.cpp:		s->s = (char*)realloc(s->s, s->m);
kstring.cpp:		l = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);
kstring.cpp:	s->l += l;
kstring.cpp:	printf("%s\n", s->s);
fastmap.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
fastmap.cpp:// --------------
fastmap.cpp:// ---------------
fastmap.cpp:    unsigned int num_cores = -1;
fastmap.cpp:/*** Memory pre-allocations ***/
fastmap.cpp:    mem_opt_t *opt = aux->opt;  
fastmap.cpp:    fprintf(stderr, "------------------------------------------\n");
fastmap.cpp:    fprintf(stderr, "1. Memory pre-allocation for Chaining: %0.4lf MB\n", allocMem/1e6);
fastmap.cpp:    allocMem = (wsize * MAX_SEQ_LEN_REF * sizeof(int8_t) + MAX_LINE_LEN) * opt->n_threads * 2+
fastmap.cpp:        (wsize * MAX_SEQ_LEN_QER * sizeof(int8_t) + MAX_LINE_LEN) * opt->n_threads  * 2 +       
fastmap.cpp:        wsize * sizeof(SeqPair) * opt->n_threads * 3;   
fastmap.cpp:    fprintf(stderr, "2. Memory pre-allocation for BSW: %0.4lf MB\n", allocMem/1e6);
fastmap.cpp:    fprintf(stderr, "3. Memory pre-allocation for BWT: %0.4lf MB\n", allocMem/1e6);
fastmap.cpp:    fprintf(stderr, "------------------------------------------\n");
fastmap.cpp:        ret->seqs = bseq_read_orig(aux->task_size,
fastmap.cpp:                                   &ret->n_seqs,
fastmap.cpp:                                   aux->ks, aux->ks2,
fastmap.cpp:        tprof[READ_IO][0] += __rdtsc() - tim;
fastmap.cpp:                aux->task_size, sz, ret->n_seqs);   
fastmap.cpp:        if (ret->seqs == 0) {
fastmap.cpp:        if (!aux->copy_comment){
fastmap.cpp:            for (int i = 0; i < ret->n_seqs; ++i){
fastmap.cpp:                free(ret->seqs[i].comment);
fastmap.cpp:                ret->seqs[i].comment = 0;
fastmap.cpp:            for (int i = 0; i < ret->n_seqs; ++i) size += ret->seqs[i].l_seq;
fastmap.cpp:                    __func__, ret->n_seqs, (long)size);
fastmap.cpp:    else if (step == 1)  /* Step 2: Main processing-engine */
fastmap.cpp:        if (w.nreads < ret->n_seqs)
fastmap.cpp:            w.nreads = ret->n_seqs;
fastmap.cpp:        if (opt->flag & MEM_F_SMARTPE)
fastmap.cpp:            bseq_classify(ret->n_seqs, ret->seqs, n_sep, sep);
fastmap.cpp:            fprintf(stderr, "[M::%s] %d single-end sequences; %d paired-end sequences.....\n",
fastmap.cpp:                /* single-end sequences, in the mixture */
fastmap.cpp:                                 aux->n_processed,
fastmap.cpp:                    ret->seqs[sep[0][i].id].sam = sep[0][i].sam;
fastmap.cpp:                /* paired-end sequences, in the mixture */
fastmap.cpp:                                 aux->n_processed + n_sep[0],
fastmap.cpp:                                 aux->pes0,
fastmap.cpp:                    ret->seqs[sep[1][i].id].sam = sep[1][i].sam;
fastmap.cpp:            /* pure (single/paired-end), reads processing */
fastmap.cpp:                             aux->n_processed,
fastmap.cpp:                             ret->n_seqs,
fastmap.cpp:                             ret->seqs,
fastmap.cpp:                             aux->pes0,
fastmap.cpp:        tprof[MEM_PROCESS2][0] += __rdtsc() - tim;
fastmap.cpp:        aux->n_processed += ret->n_seqs;
fastmap.cpp:        for (int i = 0; i < ret->n_seqs; ++i)
fastmap.cpp:            if (ret->seqs[i].sam) {
fastmap.cpp:                // err_fputs(ret->seqs[i].sam, stderr);
fastmap.cpp:                fputs(ret->seqs[i].sam, aux->fp);
fastmap.cpp:            free(ret->seqs[i].name); free(ret->seqs[i].comment);
fastmap.cpp:            free(ret->seqs[i].seq); free(ret->seqs[i].qual);
fastmap.cpp:            free(ret->seqs[i].sam);
fastmap.cpp:        free(ret->seqs);
fastmap.cpp:        tprof[SAM_IO][0] += __rdtsc() - tim;
fastmap.cpp:    ktp_t *p = w->pl;
fastmap.cpp:    while (w->step < p->n_steps) {
fastmap.cpp:        int pthread_ret = pthread_mutex_lock(&p->mutex);
fastmap.cpp:            for (i = 0; i < p->n_workers; ++i) {
fastmap.cpp:                if (w == &p->workers[i]) continue; // ignore itself
fastmap.cpp:                if (p->workers[i].step <= w->step && p->workers[i].index < w->index)
fastmap.cpp:            if (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps
fastmap.cpp:            pthread_ret = pthread_cond_wait(&p->cv, &p->mutex);
fastmap.cpp:        pthread_ret = pthread_mutex_unlock(&p->mutex);
fastmap.cpp:        // working on w->step
fastmap.cpp:        w->data = kt_pipeline(p->shared, w->step, w->step? w->data : 0, w->opt, *(w->w)); // for the first step, input is NULL
fastmap.cpp:        pthread_ret = pthread_mutex_lock(&p->mutex);
fastmap.cpp:        w->step = w->step == p->n_steps - 1 || w->data? (w->step + 1) % p->n_steps : p->n_steps;
fastmap.cpp:        if (w->step == 0) w->index = p->index++;
fastmap.cpp:        pthread_ret = pthread_cond_broadcast(&p->cv);
fastmap.cpp:        pthread_ret = pthread_mutex_unlock(&p->mutex);
fastmap.cpp:    mem_opt_t   *opt = aux->opt;
fastmap.cpp:    int32_t nthreads = opt->n_threads; // global variable for profiling!
fastmap.cpp:    w.nthreads = opt->n_threads;
fastmap.cpp:        int slookup[256] = {-1};
fastmap.cpp:                    if (v == 1) v = sscanf(ch, "%u-%u",&a,&b);
fastmap.cpp:                        fprintf(stderr, "Mis-match between HT and threads_sibling_list...%s\n", ch);
fastmap.cpp:                if (slookup[i] == -1) {
fastmap.cpp:    int32_t nreads = aux->actual_chunk_size/ READ_LEN + 10;
fastmap.cpp:    w.ref_string = aux->ref_string;
fastmap.cpp:    w.fmi = aux->fmi;
fastmap.cpp:        wr->step = 0; wr->pl = &aux_; wr->data = 0;
fastmap.cpp:        wr->index = aux_.index++;
fastmap.cpp:        wr->i = i;
fastmap.cpp:        wr->opt = opt;
fastmap.cpp:        wr->w = &w;
fastmap.cpp:    if (opt0->a) { // matching score is changed
fastmap.cpp:        if (!opt0->b) opt->b *= opt->a;
fastmap.cpp:        if (!opt0->T) opt->T *= opt->a;
fastmap.cpp:        if (!opt0->o_del) opt->o_del *= opt->a;
fastmap.cpp:        if (!opt0->e_del) opt->e_del *= opt->a;
fastmap.cpp:        if (!opt0->o_ins) opt->o_ins *= opt->a;
fastmap.cpp:        if (!opt0->e_ins) opt->e_ins *= opt->a;
fastmap.cpp:        if (!opt0->zdrop) opt->zdrop *= opt->a;
fastmap.cpp:        if (!opt0->pen_clip5) opt->pen_clip5 *= opt->a;
fastmap.cpp:        if (!opt0->pen_clip3) opt->pen_clip3 *= opt->a;
fastmap.cpp:        if (!opt0->pen_unpaired) opt->pen_unpaired *= opt->a;
fastmap.cpp:    fprintf(stderr, "Usage: bwa-mem2 mem [options] <idxbase> <in1.fq> [in2.fq]\n");
fastmap.cpp:    fprintf(stderr, "    -o STR        Output SAM file name\n");
fastmap.cpp:    fprintf(stderr, "    -t INT        number of threads [%d]\n", opt->n_threads);
fastmap.cpp:    fprintf(stderr, "    -k INT        minimum seed length [%d]\n", opt->min_seed_len);
fastmap.cpp:    fprintf(stderr, "    -w INT        band width for banded alignment [%d]\n", opt->w);
fastmap.cpp:    fprintf(stderr, "    -d INT        off-diagonal X-dropoff [%d]\n", opt->zdrop);
fastmap.cpp:    fprintf(stderr, "    -r FLOAT      look for internal seeds inside a seed longer than {-k} * FLOAT [%g]\n", opt->split_factor);
fastmap.cpp:    fprintf(stderr, "    -y INT        seed occurrence for the 3rd round seeding [%ld]\n", (long)opt->max_mem_intv);
fastmap.cpp:    fprintf(stderr, "    -c INT        skip seeds with more than INT occurrences [%d]\n", opt->max_occ);
fastmap.cpp:    fprintf(stderr, "    -D FLOAT      drop chains shorter than FLOAT fraction of the longest overlapping chain [%.2f]\n", opt->drop_ratio);
fastmap.cpp:    fprintf(stderr, "    -W INT        discard a chain if seeded bases shorter than INT [0]\n");
fastmap.cpp:    fprintf(stderr, "    -m INT        perform at most INT rounds of mate rescues for each read [%d]\n", opt->max_matesw);
fastmap.cpp:    fprintf(stderr, "    -S            skip mate rescue\n");
fastmap.cpp:    fprintf(stderr, "    -o            output file name missing\n");
fastmap.cpp:    fprintf(stderr, "    -P            skip pairing; mate rescue performed unless -S also in use\n");
fastmap.cpp:    fprintf(stderr, "   -A INT        score for a sequence match, which scales options -TdBOELU unless overridden [%d]\n", opt->a);
fastmap.cpp:    fprintf(stderr, "   -B INT        penalty for a mismatch [%d]\n", opt->b);
fastmap.cpp:    fprintf(stderr, "   -O INT[,INT]  gap open penalties for deletions and insertions [%d,%d]\n", opt->o_del, opt->o_ins);
fastmap.cpp:    fprintf(stderr, "   -E INT[,INT]  gap extension penalty; a gap of size k cost '{-O} + {-E}*k' [%d,%d]\n", opt->e_del, opt->e_ins);
fastmap.cpp:    fprintf(stderr, "   -L INT[,INT]  penalty for 5'- and 3'-end clipping [%d,%d]\n", opt->pen_clip5, opt->pen_clip3);
fastmap.cpp:    fprintf(stderr, "   -U INT        penalty for an unpaired read pair [%d]\n", opt->pen_unpaired);
fastmap.cpp://  fprintf(stderr, "   -x STR        read type. Setting -x changes multiple parameters unless overriden [null]\n");
fastmap.cpp://  fprintf(stderr, "                 pacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref)\n");
fastmap.cpp://  fprintf(stderr, "                 ont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref)\n");
fastmap.cpp://  fprintf(stderr, "                 intractg: -B9 -O16 -L5  (intra-species contigs to ref)\n");
fastmap.cpp:    fprintf(stderr, "   -p            smart pairing (ignoring in2.fq)\n");
fastmap.cpp:    fprintf(stderr, "   -R STR        read group header line such as '@RG\\tID:foo\\tSM:bar' [null]\n");
fastmap.cpp:    fprintf(stderr, "   -H STR/FILE   insert STR to header if it starts with @; or insert lines in FILE [null]\n");
fastmap.cpp:    fprintf(stderr, "   -j            treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file)\n");
fastmap.cpp:    fprintf(stderr, "   -5            for split alignment, take the alignment with the smallest coordinate as primary\n");
fastmap.cpp:    fprintf(stderr, "   -q            don't modify mapQ of supplementary alignments\n");
fastmap.cpp:    fprintf(stderr, "   -K INT        process INT input bases in each batch regardless of nThreads (for reproducibility) []\n");    
fastmap.cpp:    fprintf(stderr, "   -v INT        verbose level: 1=error, 2=warning, 3=message, 4+=debugging [%d]\n", bwa_verbose);
fastmap.cpp:    fprintf(stderr, "   -T INT        minimum score to output [%d]\n", opt->T);
fastmap.cpp:    fprintf(stderr, "   -h INT[,INT]  if there are <INT hits with score >80%% of the max score, output all in XA [%d,%d]\n", opt->max_XA_hits, opt->max_XA_hits_alt);
fastmap.cpp:    fprintf(stderr, "   -a            output all alignments for SE or unpaired PE\n");
fastmap.cpp:    fprintf(stderr, "   -C            append FASTA/FASTQ comment to SAM output\n");
fastmap.cpp:    fprintf(stderr, "   -V            output the reference FASTA header in the XR tag\n");
fastmap.cpp:    fprintf(stderr, "   -Y            use soft clipping for supplementary alignments\n");
fastmap.cpp:    fprintf(stderr, "   -M            mark shorter split hits as secondary\n");
fastmap.cpp:    fprintf(stderr, "   -I FLOAT[,FLOAT[,INT[,INT]]]\n");
fastmap.cpp:    int          fixed_chunk_size          = -1;
fastmap.cpp:        if (c == 'k') opt->min_seed_len = atoi(optarg), opt0.min_seed_len = 1;
fastmap.cpp:        else if (c == 'w') opt->w = atoi(optarg), opt0.w = 1;
fastmap.cpp:        else if (c == 'A') opt->a = atoi(optarg), opt0.a = 1, assert(opt->a >= INT_MIN && opt->a <= INT_MAX);
fastmap.cpp:        else if (c == 'B') opt->b = atoi(optarg), opt0.b = 1, assert(opt->b >= INT_MIN && opt->b <= INT_MAX);
fastmap.cpp:        else if (c == 'T') opt->T = atoi(optarg), opt0.T = 1, assert(opt->T >= INT_MIN && opt->T <= INT_MAX);
fastmap.cpp:            opt->pen_unpaired = atoi(optarg), opt0.pen_unpaired = 1, assert(opt->pen_unpaired >= INT_MIN && opt->pen_unpaired <= INT_MAX);
fastmap.cpp:            opt->n_threads = atoi(optarg), opt->n_threads = opt->n_threads > 1? opt->n_threads : 1, assert(opt->n_threads >= INT_MIN && opt->n_threads <= INT_MAX);
fastmap.cpp:        else if (c == 'P') opt->flag |= MEM_F_NOPAIRING;
fastmap.cpp:        else if (c == 'a') opt->flag |= MEM_F_ALL;
fastmap.cpp:        else if (c == 'p') opt->flag |= MEM_F_PE | MEM_F_SMARTPE;
fastmap.cpp:        else if (c == 'M') opt->flag |= MEM_F_NO_MULTI;
fastmap.cpp:        else if (c == 'S') opt->flag |= MEM_F_NO_RESCUE;
fastmap.cpp:        else if (c == 'Y') opt->flag |= MEM_F_SOFTCLIP;
fastmap.cpp:        else if (c == 'V') opt->flag |= MEM_F_REF_HDR;
fastmap.cpp:        else if (c == '5') opt->flag |= MEM_F_PRIMARY5 | MEM_F_KEEP_SUPP_MAPQ; // always apply MEM_F_KEEP_SUPP_MAPQ with -5
fastmap.cpp:        else if (c == 'q') opt->flag |= MEM_F_KEEP_SUPP_MAPQ;
fastmap.cpp:        else if (c == 'c') opt->max_occ = atoi(optarg), opt0.max_occ = 1;
fastmap.cpp:        else if (c == 'd') opt->zdrop = atoi(optarg), opt0.zdrop = 1;
fastmap.cpp:            opt->split_factor = atof(optarg), opt0.split_factor = 1.;
fastmap.cpp:        else if (c == 'D') opt->drop_ratio = atof(optarg), opt0.drop_ratio = 1.;
fastmap.cpp:        else if (c == 'm') opt->max_matesw = atoi(optarg), opt0.max_matesw = 1;
fastmap.cpp:        else if (c == 's') opt->split_width = atoi(optarg), opt0.split_width = 1;
fastmap.cpp:            opt->max_chain_gap = atoi(optarg), opt0.max_chain_gap = 1;
fastmap.cpp:            opt->max_chain_extend = atoi(optarg), opt0.max_chain_extend = 1;
fastmap.cpp:            opt->min_chain_weight = atoi(optarg), opt0.min_chain_weight = 1;
fastmap.cpp:            opt->max_mem_intv = atol(optarg), opt0.max_mem_intv = 1;
fastmap.cpp:        else if (c == 'X') opt->mask_level = atof(optarg);
fastmap.cpp:            opt->max_XA_hits = opt->max_XA_hits_alt = strtol(optarg, &p, 10);
fastmap.cpp:                opt->max_XA_hits_alt = strtol(p+1, &p, 10);
fastmap.cpp:            opt->mapQ_coef_len = atoi(optarg);
fastmap.cpp:            opt->mapQ_coef_fac = opt->mapQ_coef_len > 0? log(opt->mapQ_coef_len) : 0;
fastmap.cpp:            opt->o_del = opt->o_ins = strtol(optarg, &p, 10);
fastmap.cpp:                opt->o_ins = strtol(p+1, &p, 10);
fastmap.cpp:            opt->e_del = opt->e_ins = strtol(optarg, &p, 10);
fastmap.cpp:                opt->e_ins = strtol(p+1, &p, 10);
fastmap.cpp:            opt->pen_clip5 = opt->pen_clip3 = strtol(optarg, &p, 10);
fastmap.cpp:                opt->pen_clip3 = strtol(p+1, &p, 10);
fastmap.cpp:                        assert(buf[i-1] == '\n');
fastmap.cpp:                        buf[i-1] = 0;
fastmap.cpp:            pes[1].low  = (int)(pes[1].avg - 4. * pes[1].std + .499);
fastmap.cpp:    if (opt->n_threads < 1) opt->n_threads = 1;
fastmap.cpp:        fprintf(stderr, "WARNING: bwa-mem2 doesn't work well with long reads or contigs; please use minimap2 instead.\n");
fastmap.cpp:            if (!opt0.o_del) opt->o_del = 16;
fastmap.cpp:            if (!opt0.o_ins) opt->o_ins = 16;
fastmap.cpp:            if (!opt0.b) opt->b = 9;
fastmap.cpp:            if (!opt0.pen_clip5) opt->pen_clip5 = 5;
fastmap.cpp:            if (!opt0.pen_clip3) opt->pen_clip3 = 5;
fastmap.cpp:            if (!opt0.o_del) opt->o_del = 1;
fastmap.cpp:            if (!opt0.e_del) opt->e_del = 1;
fastmap.cpp:            if (!opt0.o_ins) opt->o_ins = 1;
fastmap.cpp:            if (!opt0.e_ins) opt->e_ins = 1;
fastmap.cpp:            if (!opt0.b) opt->b = 1;
fastmap.cpp:            if (opt0.split_factor == 0.) opt->split_factor = 10.;
fastmap.cpp:                if (!opt0.min_chain_weight) opt->min_chain_weight = 20;
fastmap.cpp:                if (!opt0.min_seed_len) opt->min_seed_len = 14;
fastmap.cpp:                if (!opt0.pen_clip5) opt->pen_clip5 = 0;
fastmap.cpp:                if (!opt0.pen_clip3) opt->pen_clip3 = 0;
fastmap.cpp:                if (!opt0.min_chain_weight) opt->min_chain_weight = 40;
fastmap.cpp:                if (!opt0.min_seed_len) opt->min_seed_len = 17;
fastmap.cpp:                if (!opt0.pen_clip5) opt->pen_clip5 = 0;
fastmap.cpp:                if (!opt0.pen_clip3) opt->pen_clip3 = 0;
fastmap.cpp:    bwa_fill_scmat(opt->a, opt->b, opt->mat);
fastmap.cpp:    aux.fmi->load_index();
fastmap.cpp:    tprof[FMI][0] += __rdtsc() - tim;
fastmap.cpp:    tprof[REF_IO][0] += timer - tim;
fastmap.cpp:        for (i = 0; i < aux.fmi->idx->bns->n_seqs; ++i)
fastmap.cpp:            aux.fmi->idx->bns->anns[i].is_alt = 0;
fastmap.cpp:    /* Handling Paired-end reads */
fastmap.cpp:        if (opt->flag & MEM_F_PE) {
fastmap.cpp:            fprintf(stderr, "[W::%s] when '-p' is in use, the second query file is ignored.\n",
fastmap.cpp:            opt->flag |= MEM_F_PE;
fastmap.cpp:    bwa_print_sam_hdr(aux.fmi->idx->bns, hdr_line, aux.fp);
fastmap.cpp:        //aux.task_size = 10000000 * opt->n_threads; //aux.actual_chunk_size;
fastmap.cpp:        aux.task_size = opt->chunk_size * opt->n_threads; //aux.actual_chunk_size;
fastmap.cpp:    tprof[MISC][1] = opt->chunk_size = aux.actual_chunk_size = aux.task_size;
fastmap.cpp:    tprof[PROCESS][0] += __rdtsc() - tim;
fastmap.cpp:    tprof[MEM][0] = __rdtsc() - tprof[MEM][0];
fastmap.cpp:    display_stats(aux.opt->n_threads);
Binary file read_index_ele.o matches
bwa.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
bwa.h:	bwt_t    *bwt; // FM-index
bwa.h:	uint8_t  *pac; // the actual 2-bit encoded reference sequences with 'N' converted to a random base
ksw.cpp: * @param mat    Scoring matrix in a one-dimension array
ksw.cpp:	p = 8 * (3 - size); // # values per __m128i
ksw.cpp:	slen = (qlen + p - 1) / p; // segmented length
ksw.cpp:	q->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory
ksw.cpp:	q->H0 = q->qp + slen * m;
ksw.cpp:	q->H1 = q->H0 + slen;
ksw.cpp:	q->E  = q->H1 + slen;
ksw.cpp:	q->Hmax = q->E + slen;
ksw.cpp:	q->slen = slen; q->qlen = qlen; q->size = size;
ksw.cpp:	for (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score
ksw.cpp:		if (mat[a] < (int8_t)q->shift) q->shift = mat[a];
ksw.cpp:		if (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];
ksw.cpp:	q->max = q->mdiff;
ksw.cpp:	q->shift = 256 - q->shift; // NB: q->shift is uint8_t
ksw.cpp:	q->mdiff += q->shift; // this is the difference between the min and max scores
ksw.cpp:	//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}
ksw.cpp:		int8_t *t = (int8_t*)q->qp;
ksw.cpp:					*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;
ksw.cpp:		int16_t *t = (int16_t*)q->qp;
ksw.cpp:			  int xtra) // the first gap costs -(_o+_e)
ksw.cpp:	int slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;
ksw.cpp:	shift = _mm_set1_epi8(q->shift);
ksw.cpp:	H0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;
ksw.cpp:	slen = q->slen;
ksw.cpp:		__m128i e, h, t, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector
ksw.cpp:		h = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example
ksw.cpp:		h = _mm_slli_si128(h, 1); // h=H(i-1,-1); << instead of >> because x64 is little-endian
ksw.cpp:			 *   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
ksw.cpp:			 *   E(i+1,j) = max{H(i,j)-q, E(i,j)-r}
ksw.cpp:			 *   F(i,j+1) = max{H(i,j)-q, F(i,j)-r}
ksw.cpp:			// compute H'(i,j); note that at the beginning, h=H'(i-1,j-1)
ksw.cpp:			h = _mm_subs_epu8(h, shift); // h=H'(i-1,j-1)+S(i,j)
ksw.cpp:			e = _mm_subs_epu8(e, e_del); // e=E'(i,j) - e_del
ksw.cpp:			t = _mm_subs_epu8(h, oe_del); // h=H'(i,j) - o_del - e_del
ksw.cpp:			t = _mm_subs_epu8(h, oe_ins); // h=H'(i,j) - o_ins - e_ins
ksw.cpp:			// get H'(i-1,j) and prepare for the next j
ksw.cpp:			h = _mm_load_si128(H0 + j); // h=H'(i-1,j)
ksw.cpp:		for (k = 0; LIKELY(k < 16); ++k) { // this block mimics SWPS3; NB: H(i,j) updated in the lazy-F loop cannot exceed max
ksw.cpp:			if (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) { // then append
ksw.cpp:			} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last
ksw.cpp:			if (gmax + q->shift >= 255 || gmax >= endsc) break;
ksw.cpp:	r.score = gmax + q->shift < 255? gmax : 255;
ksw.cpp:	if (r.score != 255) { // get a->qe, the end of query match; find the 2nd best score
ksw.cpp:		int max = -1, tmp, low, high, qlen = slen * 16;
ksw.cpp:			i = (r.score + q->max - 1) / q->max;
ksw.cpp:			low = te - i; high = te + i;
ksw.cpp:kswr_t ksw_i16(kswq_t *q, int tlen, const uint8_t *target, int _o_del, int _e_del, int _o_ins, int _e_ins, int xtra) // the first gap costs -(_o+_e)
ksw.cpp:	int slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;
ksw.cpp:	H0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;
ksw.cpp:	slen = q->slen;
ksw.cpp:		__m128i e, t, h, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector
ksw.cpp:		h = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example
ksw.cpp:			if (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) {
ksw.cpp:			} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last
ksw.cpp:		int max = -1, tmp, low, high, qlen = slen * 8;
ksw.cpp:		for (i = 0, r.qe = -1; i < qlen; ++i, ++t)
ksw.cpp:			i = (r.score + q->max - 1) / q->max;
ksw.cpp:			low = te - i; high = te + i;
ksw.cpp:		t = s[i], s[i] = s[l - 1 - i], s[l - 1 - i] = t;
ksw.cpp:	func = q->size == 2? ksw_i16 : ksw_u8;
ksw.cpp:	size = q->size;
ksw.cpp:		r.tb = r.te - rr.te, r.qb = r.qe - rr.qe;
ksw.cpp:	func = q->size == 2? ksw_i16 : ksw_u8;
ksw.cpp:	size = q->size;
ksw.cpp:	// tprof[ALIGN1][tid] += __rdtsc() - tim;
ksw.cpp:	// tprof[ALIGN1][tid] += __rdtsc() - tim;
ksw.cpp:		r.tb = r.te - rr.te, r.qb = r.qe - rr.qe;
ksw.cpp:	eh[0].h = h0; eh[1].h = h0 > oe_ins? h0 - oe_ins : 0;
ksw.cpp:	for (j = 2; j <= qlen && eh[j-1].h > e_ins; ++j)
ksw.cpp:		eh[j].h = eh[j-1].h - e_ins;
ksw.cpp:	max_ins = (int)((double)(qlen * max + end_bonus - o_ins) / e_ins + 1.);
ksw.cpp:	max_del = (int)((double)(qlen * max + end_bonus - o_del) / e_del + 1.);
ksw.cpp:	max = h0, max_i = max_j = -1; max_ie = -1, gscore = -1;
ksw.cpp:		int t, f = 0, h1, m = 0, mj = -1;
ksw.cpp:		if (beg < i - w) beg = i - w;
ksw.cpp:			h1 = h0 - (o_del + e_del * (i + 1));
ksw.cpp:			// At the beginning of the loop: eh[j] = { H(i-1,j-1), E(i,j) }, f = F(i,j) and h1 = H(i,j-1)
ksw.cpp:			// Similar to SSE2-SW, cells are computed in the following order:
ksw.cpp:			//   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
ksw.cpp:			//   E(i+1,j) = max{H(i,j)-gapo, E(i,j)} - gape
ksw.cpp:			//   F(i,j+1) = max{H(i,j)-gapo, F(i,j)} - gape
ksw.cpp:			int h, M = p->h, e = p->e; // get H(i-1,j-1) and E(i-1,j)
ksw.cpp:			p->h = h1;          // set H(i,j-1) for the next row
ksw.cpp:			h = M > e? M : e;   // e and f are guaranteed to be non-negative, so h>=0 even if M<0
ksw.cpp:			t = M - oe_del;
ksw.cpp:			e -= e_del;
ksw.cpp:			p->e = e;           // save E(i+1,j) for the next row
ksw.cpp:			t = M - oe_ins;
ksw.cpp:			f -= e_ins;
ksw.cpp:			max_off = max_off > abs(mj - i)? max_off : abs(mj - i);
ksw.cpp:			if (i - max_i > mj - max_j) {
ksw.cpp:				if (max - m - ((i - max_i) - (mj - max_j)) * e_del > zdrop) break;
ksw.cpp:				if (max - m - ((mj - max_j) - (i - max_i)) * e_ins > zdrop) break;
ksw.cpp:		for (j = end; LIKELY(j >= beg) && eh[j].h == 0 && eh[j].e == 0; --j);
ksw.cpp:#define MINUS_INF -0x40000000
ksw.cpp:	if (*n_cigar == 0 || op != (cigar[(*n_cigar) - 1]&0xf)) {
ksw.cpp:	} else cigar[(*n_cigar)-1] += len<<4;
ksw.cpp:		eh[j].h = -(o_ins + e_ins * j), eh[j].e = MINUS_INF;
ksw.cpp:	for (; j <= qlen; ++j) eh[j].h = eh[j].e = MINUS_INF; // everything is -inf outside the band
ksw.cpp:		beg = i > w? i - w : 0;
ksw.cpp:		h1 = beg == 0? -(o_del + e_del * (i + 1)) : MINUS_INF;
ksw.cpp:				// At the beginning of the loop: eh[j] = { H(i-1,j-1), E(i,j) }, f = F(i,j) and h1 = H(i,j-1)
ksw.cpp:				//   M(i,j)   = H(i-1,j-1) + S(i,j)
ksw.cpp:				//   E(i+1,j) = max{M(i,j)-gapo, E(i,j)} - gape
ksw.cpp:				//   F(i,j+1) = max{M(i,j)-gapo, F(i,j)} - gape
ksw.cpp:				int32_t h, m = p->h, e = p->e;
ksw.cpp:				p->h = h1;
ksw.cpp:				t = m - oe_del;
ksw.cpp:				e -= e_del;
ksw.cpp:				p->e = e;
ksw.cpp:				t = m - oe_ins;
ksw.cpp:				f -= e_ins;
ksw.cpp:				zi[j - beg] = d; // z[i,j] keeps h for the current cell and e/f for the next cell
ksw.cpp:				int32_t h, m = p->h, e = p->e;
ksw.cpp:				p->h = h1;
ksw.cpp:				t = m - oe_del;
ksw.cpp:				e -= e_del;
ksw.cpp:				p->e = e;
ksw.cpp:				t = m - oe_ins;
ksw.cpp:				f -= e_ins;
ksw.cpp:		i = tlen - 1; k = (i + w + 1 < qlen? i + w + 1 : qlen) - 1; // (i,k) points to the last cell
ksw.cpp:			which = z[(long)i * n_col + (k - (i > w? i - w : 0))] >> (which<<1) & 3;
ksw.cpp:			if (which == 0)      cigar = push_cigar(&n_cigar, &m_cigar, cigar, 0, 1), --i, --k;
ksw.cpp:			else if (which == 1) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 2, 1), --i;
ksw.cpp:			else                 cigar = push_cigar(&n_cigar, &m_cigar, cigar, 1, 1), --k;
ksw.cpp:			tmp = cigar[i], cigar[i] = cigar[n_cigar-1-i], cigar[n_cigar-1-i] = tmp;
ksw.cpp:		fprintf(stderr, "Usage: ksw [-1] [-f] [-a%d] [-b%d] [-q%d] [-r%d] [-t%d] <target.fa> <query.fa>\n", sa, sb, gapo, gape, minsc);
ksw.cpp:			mat[k++] = i == j? sa : -sb;
ksw.cpp:	// all-pair alignment
ksw.cpp:		for (i = 0; i < (int)ksq->seq.l; ++i) ksq->seq.s[i] = seq_nt4_table[(int)ksq->seq.s[i]];
ksw.cpp:			if ((int)ksq->seq.m > max_rseq) {
ksw.cpp:				max_rseq = ksq->seq.m;
ksw.cpp:			for (i = 0, j = ksq->seq.l - 1; i < (int)ksq->seq.l; ++i, --j)
ksw.cpp:				rseq[j] = ksq->seq.s[i] == 4? 4 : 3 - ksq->seq.s[i];
ksw.cpp:			for (i = 0; i < (int)kst->seq.l; ++i) kst->seq.s[i] = seq_nt4_table[(int)kst->seq.s[i]];
ksw.cpp:			r = ksw_align(ksq->seq.l, (uint8_t*)ksq->seq.s, kst->seq.l, (uint8_t*)kst->seq.s, 5, mat, gapo, gape, xtra, &q[0]);
ksw.cpp:				err_printf("%s\t%d\t%d\t%s\t%d\t%d\t%d\t%d\t%d\n", kst->name.s, r.tb, r.te+1, ksq->name.s, r.qb, r.qe+1, r.score, r.score2, r.te2);
ksw.cpp:				r = ksw_align(ksq->seq.l, rseq, kst->seq.l, (uint8_t*)kst->seq.s, 5, mat, gapo, gape, xtra, &q[1]);
ksw.cpp:					err_printf("%s\t%d\t%d\t%s\t%d\t%d\t%d\t%d\t%d\n", kst->name.s, r.tb, r.te+1, ksq->name.s, (int)ksq->seq.l - r.qb, (int)ksq->seq.l - 1 - r.qe, r.score, r.score2, r.te2);
Binary file kswv.o matches
ksort.h:  2008-11-16 (0.1.4):
ksort.h:  2008-11-05 (0.1.3):
ksort.h:  2008-09-15 (0.1.2):
ksort.h:  2008-09-13 (0.1.1):
ksort.h:	* Added k-small algorithm
ksort.h:  2008-09-05 (0.1.0):
ksort.h:			a = a2[curr]; b = a2[1-curr];								\
ksort.h:					if (i == eb - 1) *p++ = *i;							\
ksort.h:			curr = 1 - curr;											\
ksort.h:			if (k != n - 1 && __sort_lt(l[k], l[k+1])) ++k;				\
ksort.h:		for (i = (lsize >> 1) - 1; i != (size_t)(-1); --i)				\
ksort.h:		for (i = lsize - 1; i > 0; --i) {								\
ksort.h:			for (j = i; j > s && __sort_lt(*j, *(j-1)); --j) {			\
ksort.h:				swap_tmp = *j; *j = *(j-1); *(j-1) = swap_tmp;			\
ksort.h:			for (i = a; i < a + n - gap; ++i) {							\
ksort.h:		top = stack; s = a; t = a + (n-1); d <<= 1;						\
ksort.h:				if (--d == 0) {											\
ksort.h:					ks_combsort_##name(t - s + 1, s);					\
ksort.h:				i = s; j = t; k = i + ((j-i)>>1) + 1;					\
ksort.h:					do --j; while (i <= j && __sort_lt(rp, *j));		\
ksort.h:				if (i-s > t-i) {										\
ksort.h:					if (i-s > 16) { top->left = s; top->right = i-1; top->depth = d; ++top; } \
ksort.h:					s = t-i > 16? i+1 : t;								\
ksort.h:					if (t-i > 16) { top->left = i+1; top->right = t; top->depth = d; ++top; } \
ksort.h:					t = i-s > 16? i-1 : s;								\
ksort.h:				} else { --top; s = (type_t*)top->left; t = (type_t*)top->right; d = top->depth; } \
ksort.h:		low = arr; high = arr + n - 1; k = arr + kk;					\
ksort.h:			mid = low + (high - low) / 2;								\
ksort.h:				do --hh; while (__sort_lt(*low, *hh));					\
ksort.h:			if (hh >= k) high = hh - 1;									\
main.h:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
Binary file bwamem_extra.o matches
kvec.h:  2008-09-22 (0.1.0):
kvec.h:#define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
kvec.h:#define kv_pop(v) ((v).a[--(v).n])
kswv.cpp:   BWA-MEM2  (Sequence alignment using Burrows-Wheeler Transform),
kswv.cpp:// ------------------------------------------------------------------------------------
kswv.cpp:// for 8-bit
kswv.cpp:// -----------------------------------------------------------------------------------
kswv.cpp:    this->m = 5;
kswv.cpp:    this->o_del = o_del;
kswv.cpp:    this->o_ins = o_ins;
kswv.cpp:    this->e_del = e_del;
kswv.cpp:    this->e_ins = e_ins;
kswv.cpp:    this->w_match    = w_match;
kswv.cpp:    this->w_mismatch = w_mismatch;
kswv.cpp:    this->w_open     = o_del;  // redundant, used in vector code.
kswv.cpp:    this->w_extend   = e_del;  // redundant, used in vector code.
kswv.cpp:    this->w_ambig    = DEFAULT_AMBIG;
kswv.cpp:    this->g_qmax = max_(w_match, w_mismatch);
kswv.cpp:    this->g_qmax = max_(this->g_qmax, w_ambig);
kswv.cpp:    this->maxRefLen = maxRefLen + 16;
kswv.cpp:    this->maxQerLen = maxQerLen + 16;
kswv.cpp:    this->swTicks = 0;
kswv.cpp:    F16     = (int16_t *)_mm_malloc(this->maxQerLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    H16_0   = (int16_t *)_mm_malloc(this->maxQerLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    H16_1   = (int16_t *)_mm_malloc(this->maxQerLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    H16_max = (int16_t *)_mm_malloc(this->maxQerLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    rowMax16 = (int16_t *)_mm_malloc(this->maxRefLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    seq1SoA = (uint8_t *)_mm_malloc(this->maxRefLen * SIMD_WIDTH8 * numThreads * sizeof(uint8_t), 64);
kswv.cpp:    seq2SoA = (uint8_t *)_mm_malloc(this->maxQerLen * SIMD_WIDTH8 * numThreads * sizeof(uint8_t), 64);
kswv.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH8 - 1) / SIMD_WIDTH8 ) * SIMD_WIDTH8;
kswv.cpp:#if SORT_PAIRS     // disbaled in bwa-mem2 (only used in separate benchmark sw code)
kswv.cpp:        int16_t *hist = (int16_t *)_mm_malloc((this->maxQerLen + 32) * numThreads *
kswv.cpp:            int16_t *myHist = hist + tid * (this->maxQerLen + 32);
kswv.cpp:                sortPairsLen(pairArray + first, last - first, myTempArray, myHist);
kswv.cpp:        uint8_t *mySeq1SoA = seq1SoA + tid * this->maxRefLen * SIMD_WIDTH8;
kswv.cpp:        uint8_t *mySeq2SoA = seq2SoA + tid * this->maxQerLen * SIMD_WIDTH8;
kswv.cpp:                seq1 = seqBufRef + (int64_t)sp.id * this->maxRefLen;
kswv.cpp:                seq2 = seqBufQer + (int64_t)sp.id * this->maxQerLen;
kswv.cpp:                // assert(sp.len2 < this->maxQerLen);
kswv.cpp:                int quanta = (sp.len2 + 16 - 1) / 16;  // based on SSE-8 bit lane
kswv.cpp:                quanta *= 16;                          // for matching the output of bwa-mem
kswv.cpp:                int quanta = (sp.len2 + 16 - 1) / 16;  // based on SSE2-8 bit lane
kswv.cpp:#if SORT_PAIRS     // disbaled in bwa-mem2 (only used in separate benchmark sw code)
kswv.cpp:                sortPairsId(pairArray + first, first, last - first, myTempArray);
kswv.cpp:    setupTicks = st2 - st1;
kswv.cpp:    sort1Ticks = st3 - st2;
kswv.cpp:    swTicks = st4 - st3;
kswv.cpp:    sort2Ticks = st5 - st4;
kswv.cpp:    mdiff = max_(this->w_match, (int8_t) this->w_mismatch);
kswv.cpp:    mdiff = max_(mdiff, (int8_t) this->w_ambig);
kswv.cpp:    shift = min_(this->w_match, (int8_t) this->w_mismatch);
kswv.cpp:    shift = min_((int8_t) shift, this->w_ambig);
kswv.cpp:    shift = 256 - (uint8_t) shift;
kswv.cpp:    temp[0] = this->w_match;                                   // states: 1. matches
kswv.cpp:    temp[1] = temp[2] = temp[3] =  this->w_mismatch;           // 2. mis-matches
kswv.cpp:    temp[4] = temp[5] = temp[6] = temp[7] =  this->w_ambig;    // 3. beyond boundary
kswv.cpp:    temp[8] = temp[9] = temp[10] = temp[11] = this->w_ambig;   // 4. 0 - sse2 region
kswv.cpp:    temp[12] = this->w_ambig;                                  // 5. ambig
kswv.cpp:    __m512i mismatch512 = _mm512_set1_epi8(this->w_mismatch + shift);
kswv.cpp:    __m512i e_del512    = _mm512_set1_epi8(this->e_del);
kswv.cpp:    __m512i oe_del512   = _mm512_set1_epi8(this->o_del + this->e_del);
kswv.cpp:    __m512i e_ins512    = _mm512_set1_epi8(this->e_ins);
kswv.cpp:    __m512i oe_ins512   = _mm512_set1_epi8(this->o_ins + this->e_ins);
kswv.cpp:    __m512i te512       = _mm512_set1_epi16(-1);  // changed to -1
kswv.cpp:    __m512i te512_      = _mm512_set1_epi16(-1);  // changed to -1
kswv.cpp:    uint8_t *H0     = H8_0 + tid * SIMD_WIDTH8 * this->maxQerLen;
kswv.cpp:    uint8_t *H1     = H8_1 + tid * SIMD_WIDTH8 * this->maxQerLen;
kswv.cpp:    uint8_t *Hmax   = H8_max + tid * SIMD_WIDTH8 * this->maxQerLen;
kswv.cpp:    uint8_t *F      = F8 + tid * SIMD_WIDTH8 * this->maxQerLen;
kswv.cpp:    uint8_t *rowMax = rowMax8 + tid * SIMD_WIDTH8 * this->maxRefLen;
kswv.cpp:        __m512i iqe512 = _mm512_set1_epi8(-1);
kswv.cpp:            _mm512_store_si512((__m512i *) (rowMax + (i-1)*SIMD_WIDTH8), pimax512);
kswv.cpp:    _mm512_store_si512((__m512i *) (rowMax + (i-1) * SIMD_WIDTH8), pimax512);
kswv.cpp:                aln[ind].tb = aln[ind].te - te[l];
kswv.cpp:                aln[ind].qb = aln[ind].qe - qe[l];
kswv.cpp:    int qmax = this->g_qmax;
kswv.cpp:        int val = (score[i] + qmax - 1) / qmax;
kswv.cpp:        low[i] = te[i] - val;
kswv.cpp:    te512 = _mm512_set1_epi16(-1);
kswv.cpp:    te512_ = _mm512_set1_epi16(-1);
kswv.cpp:    // Added new block -- due to bug
kswv.cpp:            aln[ind].score2 = (temp[i] == 0? (int)-1: (uint8_t) temp[i]);
kswv.cpp:            aln[ind].score2 = -1;
kswv.cpp:            aln[ind].te2 = -1;
kswv.cpp:    seq1SoA = (int16_t *)_mm_malloc(this->maxRefLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    seq2SoA = (int16_t *)_mm_malloc(this->maxQerLen * SIMD_WIDTH16 * numThreads * sizeof(int16_t), 64);
kswv.cpp:    int32_t roundNumPairs = ((numPairs + SIMD_WIDTH16 - 1) / SIMD_WIDTH16 ) * SIMD_WIDTH16;
kswv.cpp:#if SORT_PAIRS     // disbaled in bwa-mem2 (only used in separate benchmark sw code)
kswv.cpp:        int16_t *hist = (int16_t *)_mm_malloc((this->maxQerLen + 32) * numThreads *
kswv.cpp:            int16_t *myHist = hist + tid * (this->maxQerLen + 32);
kswv.cpp:                sortPairsLen(pairArray + first, last - first, myTempArray, myHist);
kswv.cpp:        mySeq1SoA = seq1SoA + tid * this->maxRefLen * SIMD_WIDTH16;
kswv.cpp:        mySeq2SoA = seq2SoA + tid * this->maxQerLen * SIMD_WIDTH16;
kswv.cpp:                seq1 = seqBufRef + (int64_t)sp.id * this->maxRefLen;
kswv.cpp:                assert(sp.len1 < this->maxRefLen);
kswv.cpp:                seq2 = seqBufQer + (int64_t)sp.id * this->maxQerLen;
kswv.cpp:                assert(sp.len2 <= this->maxQerLen);
kswv.cpp:                // int quanta = 8 - sp.len2 % 8;  // based on SSE-16 bit lane
kswv.cpp:                int quanta = (sp.len2 + 8 - 1)/8;  // based on SSE-16 bit lane
kswv.cpp:                assert(sp.len2 < this->maxQerLen);
kswv.cpp:                assert(quanta < this->maxQerLen); 
kswv.cpp:                int quanta = (sp.len2 + 8 - 1)/8;  // based on SSE2-16 bit lane
kswv.cpp:#if SORT_PAIRS     // disbaled in bwa-mem2 (only used in separate benchmark sw code)
kswv.cpp:                sortPairsId(pairArray + first, first, last - first, myTempArray);
kswv.cpp:    setupTicks = st2 - st1;
kswv.cpp:    sort1Ticks = st3 - st2;
kswv.cpp:    swTicks = st4 - st3;
kswv.cpp:    sort2Ticks = st5 - st4;
kswv.cpp:    __m512i minus1  = _mm512_set1_epi16(-1);
kswv.cpp:    // temp[0] = this->w_match;
kswv.cpp:    // temp[1] = temp[2] = temp[3] =  this->w_mismatch;
kswv.cpp:    // temp[4] = temp[5] = temp[6] = temp[7] =  this->w_mismatch;
kswv.cpp:    // temp[16] = temp[17] = temp[18] = temp[19] = this->w_ambig;
kswv.cpp:    // temp[31] =  this->w_ambig;
kswv.cpp:    // temp[12] = temp[13] = temp[14] = temp[15] =  this->w_ambig;
kswv.cpp:    // temp[10] = temp[20] = temp[30] = this->w_mismatch;
kswv.cpp:    temp[0] = this->w_match;    // matching
kswv.cpp:    temp[1]  = temp[2]  = temp[3]  =  this->w_mismatch;  // mis-matching    
kswv.cpp:    temp[12] = temp[13] = temp[14] = temp[15] =  this->w_ambig;
kswv.cpp:    temp[16] = temp[17] = temp[18] = temp[19] = this->w_ambig;
kswv.cpp:    temp[31] = this->w_ambig;
kswv.cpp:            //  minsc[i] = -1;
kswv.cpp:            //  endsc[i] = -1;
kswv.cpp:    __m512i e_del512    = _mm512_set1_epi16(this->e_del);
kswv.cpp:    __m512i oe_del512   = _mm512_set1_epi16(this->o_del + this->e_del);
kswv.cpp:    __m512i e_ins512    = _mm512_set1_epi16(this->e_ins);
kswv.cpp:    __m512i oe_ins512   = _mm512_set1_epi16(this->o_ins + this->e_ins);
kswv.cpp:    // __m512i te512       = zero512;  // change to -1
kswv.cpp:    __m512i te512       = _mm512_set1_epi16(-1);
kswv.cpp:    int16_t *H0     = H16_0 + tid * SIMD_WIDTH16 * this->maxQerLen;
kswv.cpp:    int16_t *H1     = H16_1 + tid * SIMD_WIDTH16 * this->maxQerLen;
kswv.cpp:    int16_t *Hmax   = H16_max + tid * SIMD_WIDTH16 * this->maxQerLen;
kswv.cpp:    int16_t *F      = F16 + tid * SIMD_WIDTH16 * this->maxQerLen;
kswv.cpp:    int16_t *rowMax = rowMax16 + tid * SIMD_WIDTH16 * this->maxRefLen;
kswv.cpp:    for (int i=ncol; i >= 0; i--) {
kswv.cpp:        __m512i iqe512 = _mm512_set1_epi16(-1);
kswv.cpp:            _mm512_store_si512((__m512i *) (rowMax + (i-1)*SIMD_WIDTH16), pimax512);
kswv.cpp:    _mm512_store_si512((__m512i *) (rowMax + (i-1) * SIMD_WIDTH16), pimax512);
kswv.cpp:                aln[ind].tb = aln[ind].te - te[l];
kswv.cpp:                aln[ind].qb = aln[ind].qe - qe[l];
kswv.cpp:    int qmax = this->g_qmax;    
kswv.cpp:        int val = (score[i] + qmax - 1) / qmax;
kswv.cpp:        low[i] = te[i] - val;
kswv.cpp:    max512 = _mm512_set1_epi16(-1);
kswv.cpp:    te512 = _mm512_set1_epi16(-1);
kswv.cpp:/* This is the original SW code from bwa-mem. We are keeping both, 8-bit and 16-bit 
kswv.cpp:    int a = this->w_match;
kswv.cpp:    int b = this->w_mismatch;
kswv.cpp:    int ambig = this->w_ambig;
kswv.cpp: * @param mat    Scoring matrix in a one-dimension array
kswv.cpp:    p = 8 * (3 - size); // # values per __m128i
kswv.cpp:    slen = (qlen + p - 1) / p; // segmented length
kswv.cpp:    q->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory
kswv.cpp:    q->H0 = q->qp + slen * m;
kswv.cpp:    q->H1 = q->H0 + slen;
kswv.cpp:    q->E  = q->H1 + slen;
kswv.cpp:    q->Hmax = q->E + slen;
kswv.cpp:    q->slen = slen; q->qlen = qlen; q->size = size;
kswv.cpp:    for (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score
kswv.cpp:        if (mat[a] < (int8_t)q->shift) q->shift = mat[a];
kswv.cpp:        if (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];
kswv.cpp:    q->max = q->mdiff;
kswv.cpp:    q->shift = 256 - q->shift; // NB: q->shift is uint8_t
kswv.cpp:    q->mdiff += q->shift; // this is the difference between the min and max scores
kswv.cpp:    //  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}
kswv.cpp:        int8_t *t = (int8_t*)q->qp;
kswv.cpp:                    *t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;
kswv.cpp:        int16_t *t = (int16_t*)q->qp;
kswv.cpp:                          int xtra) // the first gap costs -(_o+_e)
kswv.cpp:    int slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;
kswv.cpp:    shift = _mm_set1_epi8(q->shift);
kswv.cpp:    H0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;
kswv.cpp:    slen = q->slen;
kswv.cpp:        __m128i e, h, t, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector
kswv.cpp:        h = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example
kswv.cpp:        h = _mm_slli_si128(h, 1); // h=H(i-1,-1); << instead of >> because x64 is little-endian
kswv.cpp:             *   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
kswv.cpp:             *   E(i+1,j) = max{H(i,j)-q, E(i,j)-r}
kswv.cpp:             *   F(i,j+1) = max{H(i,j)-q, F(i,j)-r}
kswv.cpp:            // compute H'(i,j); note that at the beginning, h=H'(i-1,j-1)
kswv.cpp:            h = _mm_subs_epu8(h, shift); // h=H'(i-1,j-1)+S(i,j)
kswv.cpp:            e = _mm_subs_epu8(e, e_del); // e=E'(i,j) - e_del
kswv.cpp:            t = _mm_subs_epu8(h, oe_del); // h=H'(i,j) - o_del - e_del
kswv.cpp:            t = _mm_subs_epu8(h, oe_ins); // h=H'(i,j) - o_ins - e_ins
kswv.cpp:            // get H'(i-1,j) and prepare for the next j
kswv.cpp:            h = _mm_load_si128(H0 + j); // h=H'(i-1,j)
kswv.cpp:        for (k = 0; LIKELY(k < 16); ++k) { // this block mimics SWPS3; NB: H(i,j) updated in the lazy-F loop cannot exceed max
kswv.cpp:            if (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) { // then append
kswv.cpp:            } else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last
kswv.cpp:            if (gmax + q->shift >= 255 || gmax >= endsc) break;
kswv.cpp:    r.score = gmax + q->shift < 255? gmax : 255;
kswv.cpp:    if (r.score != 255) { // get a->qe, the end of query match; find the 2nd best score
kswv.cpp:        int max = -1, tmp, low, high, qlen = slen * 16;
kswv.cpp:            assert(q->max != 0);
kswv.cpp:            i = (r.score + q->max - 1) / q->max;
kswv.cpp:            low = te - i; high = te + i;
kswv.cpp:                            int xtra) // the first gap costs -(_o+_e)
kswv.cpp:    int slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;
kswv.cpp:    H0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;
kswv.cpp:    slen = q->slen;
kswv.cpp:        __m128i e, t, h, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector
kswv.cpp:        h = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example
kswv.cpp:            if (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) {
kswv.cpp:            } else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last
kswv.cpp:        int max = -1, tmp, low, high, qlen = slen * 8;
kswv.cpp:        for (i = 0, r.qe = -1; i < qlen; ++i, ++t)
kswv.cpp:            assert(q->max != 0);
kswv.cpp:            i = (r.score + q->max - 1) / q->max;
kswv.cpp:            low = te - i; high = te + i;
kswv.cpp:// -------------------------------------------------------------
kswv.cpp://-------------------------------------------------------------
kswv.cpp:        kswr_t *myaln = aln + p->regid;
kswv.cpp:        uint8_t *target = seqBufRef + p->idr;
kswv.cpp:        uint8_t *query = seqBufQer + p->idq;
kswv.cpp:        int tlen = p->len1;
kswv.cpp:        int qlen = p->len2;
kswv.cpp:        int xtra = p->h0;
kswv.cpp:            q = ksw_qinit((xtra & KSW_XBYTE)? 1 : 2, qlen, query, this->m, mat);
kswv.cpp:            q = ksw_qinit(2, qlen, query, this->m, mat);
kswv.cpp:        myaln->score = ks.score;
kswv.cpp:        myaln->tb = ks.tb;
kswv.cpp:        myaln->te = ks.te;
kswv.cpp:        myaln->qb = ks.qb;
kswv.cpp:        myaln->qe = ks.qe;
kswv.cpp:        myaln->score2 = ks.score2;
kswv.cpp:        myaln->te2 = ks.te2;
kswv.cpp:#define DEFAULT_MISMATCH -4
kswv.cpp:#define DEFAULT_AMBIG -1
kswv.cpp:// #define MATRIX_MIN_CUTOFF -100000000
kswv.cpp:        if(strcmp(argv[i], "-match") == 0)
kswv.cpp:        if(strcmp(argv[i], "-mismatch") == 0) //penalty, +ve number
kswv.cpp:        if(strcmp(argv[i], "-ambig") == 0)
kswv.cpp:        if(strcmp(argv[i], "-gapo") == 0)
kswv.cpp:        if(strcmp(argv[i], "-gape") == 0)
kswv.cpp:        if(strcmp(argv[i], "-pairs") == 0)
kswv.cpp:        if(strcmp(argv[i], "-h0") == 0)
kswv.cpp:        if(!fgets((char *)(seqBufRef + numPairs * this->maxRefLen), this->maxRefLen, pairFile))
kswv.cpp:        if(!fgets((char *)(seqBufQer + numPairs * this->maxQerLen), this->maxQerLen, pairFile)) 
kswv.cpp:        sp.len1 = strnlen((char *)(seqBufRef + numPairs * this->maxRefLen), this->maxRefLen) - 1;
kswv.cpp:        sp.len2 = strnlen((char *)(seqBufQer + numPairs * this->maxQerLen), this->maxQerLen) - 1;
kswv.cpp:        uint8_t *seq1 = seqBufRef + numPairs * this->maxRefLen;
kswv.cpp:        uint8_t *seq2 = seqBufQer + numPairs * this->maxQerLen;
kswv.cpp:            seq1[l] -= 48;
kswv.cpp:            seq2[l] -= 48;
kswv.cpp:    seqBufRef = (uint8_t *)_mm_malloc((this->maxRefLen * MAX_NUM_PAIRS + MAX_LINE_LEN)
kswv.cpp:    seqBufQer = (uint8_t *)_mm_malloc((this->maxQerLen * MAX_NUM_PAIRS + MAX_LINE_LEN)
kswv.cpp:               ((int64_t)(this->maxRefLen + this->maxQerLen ) * MAX_NUM_PAIRS + MAX_LINE_LEN)/1e6);
kswv.cpp:        if(tid == (nt - 1))
kswv.cpp:#if SORT_PAIRS     // disbaled in bwa-mem2 (only used in separate benchmark sw code)
kswv.cpp:    freq = __rdtsc() - tim;
kswv.cpp:        if (totNumPairs > spot) spot -= totNumPairs - numPairs;
kswv.cpp:        readTim += __rdtsc() - tim;
kswv.cpp:        pwsw->getScores8(seqPairArray, seqBufRef, seqBufQer, aln, numPairs, numThreads, phase);
kswv.cpp:        // pwsw->getScores16(seqPairArray, seqBufRef, seqBufQer, aln, numPairs, numThreads, phase);
kswv.cpp:        myTicks += __rdtsc() - tim;
kswv.cpp:        // printf("Vector code -- Wrote output to the file\n");
kswv.cpp:    // int64_t myTicks = 0;//pwsw->getTicks();
kswv.cpp:        printf("Time in pre-processing: %0.2lf (%0.2lf, %0.2lf)\n",
kswv.cpp:        if (totNumPairs > spot) spot -= totNumPairs - numPairs;
kswv.cpp:        readTim += __rdtsc() - tim;
kswv.cpp:        pwsw->kswvScalarWrapper(seqPairArray,
kswv.cpp:        myTicks += __rdtsc() - tim;
